\input texinfo.tex
@c %**start of header
@setfilename ccpathnames.info
@settitle CCPathnames
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      CCPathnames

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    CCPathnames

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           ccpathnames

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2018

@c ------------------------------------------------------------

@set CCEXCEPTIONS_VERSION       0.6.4-devel.3

@set GITHUB_URL                 @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BITBUCKET_URL              @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DOWNLOAD_URL               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DOCUMENTATION_URL          @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library
implementing Unix pathnames manipulation functions.

This package supports @posix{} platforms.  This package depends on the package CCExceptions, at
least version @value{CCEXCEPTIONS_VERSION}.

The package is distributed under the terms of the @gnu{} Lesser General Public License (@lgpl{}).

The latest release can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} General
Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* ccpathnames: (ccpathnames).   CCPathnames a Unix pathnames
                                manipulation library.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* init::                        Library initialisation.
* conditions::                  Exceptional condition objects.
* typedefs::                    Type definitions.
* ctors::                       Constructing pathname representations.
* dtors::                       Destructing pathname representations.
* predicates::                  Pathname predicates.
* accessors::                   Pathname accessors.
* manipulations::               Pathname manipulations.
* utils::                       Utility definitions.

Appendices

* Package License::             GNU Lesser General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library
implementing Unix pathnames manipulation functions.

This package supports @posix{} platforms.  This package depends on the package CCExceptions, at
least version @value{CCEXCEPTIONS_VERSION}.

@value{PACKAGE} installs the single header file @file{ccpathnames.h}.  All the function names in the
@api{} are prefixed with @code{ccptn_}; all the preprocessor symbol names are prefixed with
@code{CCPTN_}; all the type names are prefixed with @code{ccptn_} and suffixed with @code{_t}.

Notice that, before using the library, we need to call the global initialisation function
@cfunc{ccptn_init}.

@menu
* overview linking::            Linking code with the library.
@end menu

@c page
@node overview linking
@section Linking code with the library


This package installs a data file for @command{pkg-config}, so when searching for the installed
library with the @gnu{} Autotools, we can add the following macro use to @file{configure.ac}:

@example
PKG_CHECK_MODULES([CCPATHNAMES],[ccpathnames >= 0.1])
@end example

@noindent
which will set the variables @code{CCPATHNAMES_LIBS} and @code{CCPATHNAMES_CFLAGS}.

Alternatively we can use the raw @gnu{} Autoconf macros:

@example
AC_CHECK_LIB([ccpathnames],[ccptn_version_string],,
  [AC_MSG_FAILURE([test for CCPathnames library failed])])
AC_CHECK_HEADERS([ccpathnames.h],,
  [AC_MSG_FAILURE([test for CCPathnames header failed])])
@end example

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@deftypefun {char const *} ccptn_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing the interface version
number.
@end deftypefun


@deftypefun int ccptn_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int ccptn_version_interface_revision (void)
Return an integer representing the library interface current revision number.
@end deftypefun


@deftypefun int ccptn_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node init
@chapter Library initialisation


@deftypefun void ccptn_init (void)
Initialises the internal structures of the library.  It is fine to call this function multiple
times.

@quotation
@strong{NOTE} This function is defined with the @gcc{} attribute @code{constructor}, so, when the
library is built with @gcc{}: it will be called automatically by the library initialisation code.
@end quotation
@end deftypefun

@c page
@node conditions
@chapter Exceptional condition objects


@menu
* conditions invalid::          Invalid pathname condition object.
@end menu

@c page
@node conditions invalid
@section Invalid pathname condition object


The @dfn{invalid pathname exceptional--condition object} has the purpose of describing an
exceptional condition caused by attempting to use an invalid pathname.

There should be only one @emph{invalid pathname} condition object: the one predefined by
@value{PACKAGE}.

All the following definitions are accessible from the header file @file{ccexceptions.h}.


@deftp {Struct Typedef} ccptn_descriptor_invalid_pathname_t
Structure type representing the descriptor for @emph{invalid pathname} condition objects.  This
descriptor has @objtype{cce_descriptor_runtime_error_t} as parent descriptor.
@end deftp


@deftp {Struct Typedef} ccptn_condition_invalid_pathname_t
Structure type representing an @emph{invalid pathname} condition object.
@end deftp


@deftypefun void ccptn_condition_init_invalid_pathname (ccptn_condition_invalid_pathname_t * @var{C})
Initialise an already allocated condition object.  This function exists to allow sub--typing from
@objtype{ccptn_condition_invalid_pathname_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} ccptn_condition_new_invalid_pathname (void)
Return a pointer to the statically allocated structure representing the single @emph{invalid
pathname} condition object.
@end deftypefun


@deftypefun bool ccptn_is_condition_invalid_pathname (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} is an @emph{invalid pathname} condition object; otherwise return
@cfalse{}.
@end deftypefun

@c page
@node typedefs
@chapter Type definitions


@deftp {Struct Typedef} ccptn_t
Structure representing a Unix pathname.  All the fields are opaque.  All the instances of this type
are immutable.

The pathname is internally represented with an @asciiz{} string.  All the octets in the range
@math{[1, 255]} are valid for the pathname.  A pathname is never empty: it always contains at least
one octet.

Instances of this type include a pointer function referencing a finalisation function appropriate
for the internal data.  We can always release the resources associated to an instance of
@objtype{ccptn_t} by applying to it the function @cfunc{ccptn_final}.
@end deftp

@c page
@node ctors
@chapter Constructing pathname representations


@deftypefun {ccptn_t *} ccptn_new_nodup_asciiz (cce_destination_t @var{L}, char const * @var{pathname})
Allocate a new @objtype{ccptn_t} instance initialising it with data from the @asciiz{} string
@var{pathname}, return a pointer to it.  If an error occurs: raise an exception by performing a
non--local exit to to @var{L}.

The data is @strong{not} duplicated: the returned @objtype{ccptn_t} references @var{pathname}
itself.  Memory is allocated with @cfunc{malloc}.  The finalisation function registered in the
instance will release the @code{struct} itself, but not the data buffer.

As usage example see the following code:

@example
cce_location_t        L[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  char const *  pathname = "/path/to/file.ext";
  ccptn_t *     P;

  P = ccptn_new_nodup_asciiz(L, pathname);
  printf("%s\n", ccptn_asciiz(P));
  ccptn_final(P);
  cce_run_cleanup_handlers(L);
@}
@end example
@end deftypefun


@deftypefun {ccptn_t *} ccptn_new_dup_asciiz (cce_destination_t @var{L}, char const * @var{pathname})
Allocate a new @objtype{ccptn_t} instance initialising it with data from the @asciiz{} string
@var{pathname}, return a pointer to it.  If an error occurs: raise an exception by performing a
non--local exit to to @var{L}.

The data @strong{is} duplicated: the returned @objtype{ccptn_t} includes a copy of the data from
@var{pathname}.  Memory is allocated with @cfunc{malloc}.  The finalisation function registered in
the instance will release the @code{struct} itself, and the data buffer.

As usage example see the following code:

@example
cce_location_t        L[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  char const *  pathname = "/path/to/file.ext";
  ccptn_t *     P;

  P = ccptn_new_dup_asciiz(L, pathname);
  printf("%s\n", ccptn_asciiz(P));
  ccptn_final(P);

  cce_run_cleanup_handlers(L);
@}
@end example
@end deftypefun


@deftypefun {ccptn_t *} ccptn_init_nodup_asciiz (cce_destination_t @var{L}, ccptn_t * @var{P}, char const * @var{pathname})
Initialise an already allocated @objtype{ccptn_t} instance with data from the @asciiz{} string
@var{pathname}.  If an error occurs: raise an exception by performing a non--local exit to to
@var{L}.

The data is @strong{not} duplicated: the instance references @var{pathname} itself.  Memory is
allocated with @cfunc{malloc}.  The finalisation function registered in the instance will do
nothing.

As usage example see the following code:

@example
cce_location_t        L[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  char const *  pathname = "/path/to/file.ext";
  ccptn_t       P[1];

  ccptn_init_nodup_asciiz(L, P, pathname);
  printf("%s\n", ccptn_asciiz(P));
  ccptn_final(P);

  cce_run_cleanup_handlers(L);
@}
@end example
@end deftypefun


@deftypefun {ccptn_t *} ccptn_init_dup_asciiz (cce_destination_t @var{L}, ccptn_t * @var{P}, char const * @var{pathname})
Initialise an already allocated @objtype{ccptn_t} instance with data from the @asciiz{} string
@var{pathname}.  If an error occurs: raise an exception by performing a non--local exit to to
@var{L}.

The data @strong{is} duplicated: the instance includes a copy of the data from @var{pathname}.
Memory is allocated with @cfunc{malloc}.  The finalisation function registered in the instance will
release the data area but not the @code{struct} itself.

As usage example see the following code:

@example
cce_location_t        L[1];

if (cce_location(L)) @{
  cce_run_error_handlers_raise(L, upper_L);
@} else @{
  char const *  pathname = "/path/to/file.ext";
  ccptn_t       P[1];

  ccptn_init_dup_asciiz(L, P, pathname);
  printf("%s\n", ccptn_asciiz(P));
  ccptn_final(P);

  cce_run_cleanup_handlers(L);
@}
@end example
@end deftypefun

@c page
@node dtors
@chapter Destructing pathname representations


@deftypefun void ccptn_final (ccptn_t * @var{P})
Release all the resources associated to the referenced instance of @objtype{ccptn_t}.
@end deftypefun


@deftypefun void ccptn_cleanup_handler_ptn_init (cce_destination_t @var{L}, cce_handler_t * @var{H}, ccptn_t * @var{P})
@deftypefunx void ccptn_error_handler_ptn_init (cce_destination_t @var{L}, cce_handler_t * @var{H}, ccptn_t * @var{P})
Register @var{H} as cleanup or error handler in the context of @var{L}.  The handler function will
finalise the pathname referenced by @var{P}.  If an error occurs while configuring the handler: an
exception is raised by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefn {Preprocessor Macro} void ccptn_handler_ptn_init (cce_destination_t @var{L}, cce_cleanup_handler_t * @var{H}, ccptn_t * @var{P})
@deftypefnx {Preprocessor Macro} void ccptn_handler_ptn_init (cce_destination_t @var{L}, cce_error_handler_t * @var{H}, ccptn_t * @var{P})
This preprocessor macro uses @code{_Generic} to dispatch the call according to the type of the
pointer @var{H}; if the type is:

@table @code
@item cce_cleanup_handler_t
The macro expands into a call to @cfunc{ccptn_cleanup_handler_ptn_init}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccptn_error_handler_ptn_init}.
@end table
@end deftypefn


As usage example of the exception handler, see the following code:

@example
cce_location_t        L[1];
cce_cleanup_handler_t P_H[1];

if (cce_location(L)) @{
  cce_run_error_handlers_final(L);
@} else @{
  char const *  pathname = "/path/to/file.ext";
  ccptn_t *     P;

  P = ccptn_new_nodup_asciiz(L, pathname);
  ccptn_handler_ptn_init(L, P_H, P);

  printf("%s\n", ccptn_asciiz(P));
  cce_run_cleanup_handlers(L);
@}
@end example

@c page
@node predicates
@chapter Pathname predicates


@deftypefun bool ccptn_is_absolute (ccptn_t const * @var{P})
Return @ctrue{} if @var{P} represents an absolute pathname; otherwise return @cfalse{}.  A pathname
is absolute if its first octet is the @ascii{} representation of @samp{/}.
@end deftypefun


@deftypefun bool ccptn_is_relative (ccptn_t const * @var{P})
Return @ctrue{} if @var{P} represents a relative pathname; otherwise return @cfalse{}.  A pathname
is relative if its first octet is @strong{not} the @ascii{} representation of @samp{/}.
@end deftypefun


@deftypefun bool ccptn_is_realpath (ccptn_t const * @var{P})
Return @ctrue{} if @var{P} is the result of a call to the system function @cfunc{realpath};
otherwise return @cfalse{}.
@end deftypefun

@c page
@node accessors
@chapter Pathname accessors


@deftypefun {char const *} ccptn_asciiz (ccptn_t const * @var{P})
Return a pointer to an @asciiz{} representation of the pathname.
@end deftypefun


@deftypefun size_t ccptn_len (ccptn_t const * @var{P})
Return the number of octets in the pathname representation, @strong{not} including the terminating
zero.
@end deftypefun

@c page
@node manipulations
@chapter Pathname manipulations


@deftypefun ccptn_t * ccptn_realpath (cce_destination_t @var{L}, ccptn_t const * @var{P})
Build and return a new pathname instance representing the result of applying the standard
@cfunc{realpath} to the pathname represented by @var{P}.  If an error occurs: raise an exception by
performing a non--local exit to to @var{L}.

Notice that the pathname has to exist for this function to succeed.
@end deftypefun


@c page
@node utils
@chapter Utility definitions


@defmac CCPTN_PC (@var{POINTER_TYPE}, @var{POINTER_NAME}, @var{EXPRESSION})
Preprocessor macro used to define pointer variables initialised with a cast expression.  It expands
to:

@example
POINTER_TYPE * POINTER_NAME = (POINTER_TYPE *) (EXPRESSION)
@end example

For example, the macro use:

@example
CCPTN_PC(ccpathnames_descriptor_test_failure_t, C, _C);
@end example

@noindent
expands into:

@example
ccpathnames_descriptor_test_failure_t * C = \
   (ccpathnames_descriptor_test_failure_t *) (_C);
@end example
@end defmac


@defmac CCPTN_UNUSED
Preprocessor macro that is meant to expand into an attribute declaration.  If the symbol
@code{__GNUC__} is defined, the expansion is:

@example
__attribute__((__unused__))
@end example

@noindent
otherwise the expansion is the empty string.
@end defmac

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include lgpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DOCUMENTATION_URL}

@noindent
the latest release of this package can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@noindent
the package CCExceptions is available at:

@center @url{https://github.com/marcomaggi/ccexceptions/}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

