\input texinfo.tex
@c %**start of header
@setfilename ccpathnames.info
@settitle CCPathnames
@c %**end of header

@include version.texi
@include macros.texi
@include ccexceptions-macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      CCPathnames

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    CCPathnames

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           ccpathnames

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2018-2019

@c ------------------------------------------------------------

@set CCExceptionsVersion       0.9.0
@set CCMemoryVersion           0.2.1
@set CCStructsVersion          0.3.0
@set CCTestsVersion            0.4.1

@c ------------------------------------------------------------

@set PackageAutoconfPrefix              CCPATHNAMES
@set PackagePkgconfigModule             ccpathnames
@set PackageLibsVar                     @env{CCPATHNAMES_LIBS}
@set PackageCflagsVar                   @env{CCPATHNAMES_CFLAGS}
@c This is the stem of the library in "libccpathnames.so".
@set PackageLibstem                     ccpathnames
@set PackageApiPrefixLower              ccptn_
@set PackageApiPrefixUpper              CCPTN_

@set PackageHeader                      ccpathnames.h
@set PackageHeaderFile                  @file{@value{PackageHeader}}

@set GithubUrl                 @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BitbucketUrl              @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DownloadUrl               @url{https://bitbucket.org/marcomaggi/@value{PACKAGE_NICKNAME}/downloads}
@set DocumentationUrl          @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library
implementing Unix file system pathnames manipulation functions.

This package supports @posix{} platforms.  This package depends on the packages: CCExceptions, at
least version @value{CCExceptionsVersion}; CCMemory, at least version @value{CCMemoryVersion};
CCStructs, at least version @value{CCStructsVersion}.  To run the test suite: this package depends
upon the package CCTests, at least version @value{CCTestsVersion}.

This package is distributed under the terms of the @gnu{} Lesser General Public License (@lgpl{}).

The latest release can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} General
Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* ccpathnames: (ccpathnames).   CCPathnames a Unix pathnames
                                manipulation library.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* init::                        Library initialisation.
* conditions::                  Exceptional condition objects.
* typedefs::                    Type definitions.
* handlers::                    Destroying pathname representations.
* ctors::                       Constructing pathname representations.
* predicates::                  Pathname predicates.
* accessors::                   Pathname accessors.
* manipulations::               Pathname manipulations.
* components::                  Pathname components.
* io::                          Pathname input/output.
* traits::                      Implemented traits.
* segments::                    Manipulating segments.
* utils::                       Utility definitions.

Appendices

* Package License::             GNU Lesser General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library
implementing Unix file system pathnames manipulation functions.

This package supports @posix{} platforms.  This package depends on the packages: CCExceptions, at
least version @value{CCExceptionsVersion}; CCMemory, at least version @value{CCMemoryVersion};
CCStructs, at least version @value{CCStructsVersion}.  To run the test suite: this package depends
upon the package CCTests, at least version @value{CCTestsVersion}.

@cindex @value{PackageHeaderFile}, header file
@cindex Header file @value{PackageHeaderFile}
@value{PACKAGE} installs the multiple header files; the whole @api{} is available by including the
single file @value{PackageHeaderFile}.  All the function names in the @api{} are prefixed with
@code{@value{PackageApiPrefixLower}}; all the preprocessor symbol names are prefixed with
@code{@value{PackageApiPrefixUpper}}; all the type names are prefixed with
@code{@value{PackageApiPrefixLower}} and suffixed with @code{_t}.

@strong{Notice that, before using the library, we need to call the global initialisation function
@cfunc{ccptn_library_init}}.

@menu
* overview linking::            Linking code with the library.
* overview ccnames::            Generated function names.
* overview exceptions::         Handling exceptional conditions.
* overview allocation::         Memory allocation for pathname instances.
@end menu

@include overview-linking.texi
@include overview-ccnames.texi
@include overview-ccexceptions.texi
@include overview-ccmemory.texi

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@deftypefun {char const *} ccptn_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing the interface version
number.
@end deftypefun


@deftypefun int ccptn_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int ccptn_version_interface_revision (void)
Return an integer representing the library interface current revision number.
@end deftypefun


@deftypefun int ccptn_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node init
@chapter Library initialisation


@deftypefun void ccptn_library_init (void)
Initialise the internal structures of the library.  It is fine to call this function multiple times.

@quotation
@strong{NOTE} This function is defined with the @gcc{} attribute @code{constructor}, so, when the
library is built with @gcc{}: it will be called automatically by the library initialisation code.
@end quotation
@end deftypefun

@c page
@node conditions
@chapter Exceptional condition objects


@menu
* conditions invalid::          Invalid pathname condition object.
* conditions length::           Maximum pathname length exceeded.
* conditions zero length::      Zero-length pathname.
* conditions invalid length::   Invalid length pathname.
* conditions normalised::       Normalised pathname required.
* conditions no dirname::       Directory part is missing.
* conditions no filename::      Filename is missing.
* conditions no tailname::      Tailname is missing.
* conditions no rootname::      Rootname is missing.
@end menu

@c page
@node conditions invalid
@section Invalid pathname condition object


The @dfn{invalid pathname exceptional--condition object--type} has the purpose of describing an
exceptional condition caused by attempting to use an invalid pathname.

All the following definitions are accessible from the header file @file{ccpathnames.h}.


@CCEDescriptorTypedef{ccptn,invalid_pathname,cce_descriptor_runtime_error_t}


@deftp {Struct Typedef} @CCEConditionObjectType{ccptn,invalid_pathname}
Type of data structure representing an exceptional--condition object.  It has the following public
fields:

@table @code
@item cce_condition_runtime_error_t runtime_error
Core values for the exceptional--condition object.
@end table
@end deftp


@CCEConditionObjectNewNoArgs{ccptn,invalid_pathname}


@CCEConditionObjectPredicate{ccptn,invalid_pathname}


@CCEConditionSubtypingFacilitiesNoArgsFailing{ccptn,invalid_pathname}

@c page
@node conditions length
@section Maximum pathname length exceeded


The @dfn{exceeded length exceptional--condition object--type} has the purpose of describing an
exceptional condition caused by attempting an operation that would generate a too long pathname.

All the following definitions are accessible from the header file @file{ccpathnames.h}.


@CCEDescriptorTypedef{ccptn,exceeded_length,cce_descriptor_runtime_error_t}


@deftp {Struct Typedef} @CCEConditionObjectType{ccptn,exceeded_length}
Type of data structure representing an exceptional--condition object.  It has the following public
fields:

@table @code
@item cce_condition_runtime_error_t runtime_error
Core values for the exceptional--condition object.
@end table
@end deftp


@CCEConditionObjectNewNoArgs{ccptn,exceeded_length}


@CCEConditionObjectPredicate{ccptn,exceeded_length}


@CCEConditionSubtypingFacilitiesNoArgsFailing{ccptn,exceeded_length}

@c page
@node conditions zero length
@section Zero--length pathname


The @dfn{zero--length exceptional--condition object--type} has the purpose of describing an exceptional
condition caused by attempting an operation that would generate zero--length pathname.

All the following definitions are accessible from the header file @file{ccpathnames.h}.


@CCEDescriptorTypedef{ccptn,zero_length,cce_descriptor_runtime_error_t}


@deftp {Struct Typedef} @CCEConditionObjectType{ccptn,zero_length}
Type of data structure representing an exceptional--condition object.  It has the following public
fields:

@table @code
@item cce_condition_runtime_error_t runtime_error
Core values for the exceptional--condition object.
@end table
@end deftp


@CCEConditionObjectNewNoArgs{ccptn,zero_length}


@CCEConditionObjectPredicate{ccptn,zero_length}


@CCEConditionSubtypingFacilitiesNoArgsFailing{ccptn,zero_length}

@c page
@node conditions invalid length
@section Invalid length pathname


The @dfn{invalid length exceptional--condition object--type} has the purpose of describing an
exceptional condition caused by attempting an operation on a pathname string that contains a
non--terminating zero octet.

All the following definitions are accessible from the header file @file{ccpathnames.h}.


@CCEDescriptorTypedef{ccptn,invalid_length,cce_descriptor_runtime_error_t}


@deftp {Struct Typedef} @CCEConditionObjectType{ccptn,invalid_length}
Type of data structure representing an exceptional--condition object.  It has the following public
fields:

@table @code
@item cce_condition_runtime_error_t runtime_error
Core values for the exceptional--condition object.
@end table
@end deftp


@CCEConditionObjectNewNoArgs{ccptn,invalid_length}


@CCEConditionObjectPredicate{ccptn,invalid_length}


@CCEConditionSubtypingFacilitiesNoArgsFailing{ccptn,invalid_length}

@c page
@node conditions normalised
@section Normalised pathname required


The @dfn{normalised pathname exceptional--condition object--type} has the purpose of describing an
exceptional condition caused by attempting an operation on a pathname that is @strong{not}
normalised, while the operation requires that it is.

All the following definitions are accessible from the header file @file{ccpathnames.h}.


@CCEDescriptorTypedef{ccptn,normalised_pathname,ccptn_descriptor_invalid_pathname_t}


@deftp {Struct Typedef} @CCEConditionObjectType{ccptn,normalised_pathname}
Type of data structure representing an exceptional--condition object.  It has the following public
fields:

@table @code
@item ccptn_condition_invalid_pathname_t invalid_pathname
Core values for the exceptional--condition object.
@end table
@end deftp


@CCEConditionObjectNewNoArgs{ccptn,normalised_pathname}


@CCEConditionObjectPredicate{ccptn,normalised_pathname}


@CCEConditionSubtypingFacilitiesNoArgsFailing{ccptn,normalised_pathname}

@c page
@node conditions no dirname
@section Directory part is missing


The @dfn{no dirname exceptional--condition object--type} has the purpose of describing an exceptional
condition caused by attempting an operation on a pathname that has no directory part, when this is
required.  The dirname is the pathname representing the input pathname with the last segment
stripped.  Examples:

@example
"/path/to/file.ext"     @result{} "/path/to"
"/path/to/dir/"         @result{} "/path/to"
"file.ext"              @error{} no dirname
"."                     @result{} ".."
".."                    @error{} no dirname
@end example

All the following definitions are accessible from the header file @file{ccpathnames.h}.


@CCEDescriptorTypedef{ccptn,no_dirname,ccptn_descriptor_invalid_pathname_t}


@deftp {Struct Typedef} @CCEConditionObjectType{ccptn,no_dirname}
Type of data structure representing an exceptional--condition object.  It has the following public
fields:

@table @code
@item ccptn_condition_invalid_pathname_t invalid_pathname
Core values for the exceptional--condition object.
@end table
@end deftp


@CCEConditionObjectNewNoArgs{ccptn,no_dirname}


@CCEConditionObjectPredicate{ccptn,no_dirname}


@CCEConditionSubtypingFacilitiesNoArgsFailing{ccptn,no_dirname}

@c page
@node conditions no filename
@section Filename is missing


The @dfn{no filename exceptional--condition object--type} has the purpose of describing an
exceptional condition caused by attempting an operation on a pathname that has no filename part,
when this is required.  The filename is the relative pathname representing the last segment if it
does not represent a directory.  Examples:

@example
"/path/to/file.ext"     @result{} "file.ext"
"/path/to/dir/"         @error{} no filename
"file.ext"              @result{} "file.ext"
"."                     @error{} no filename
".."                    @error{} no filename
@end example

All the following definitions are accessible from the header file @file{ccpathnames.h}.


@CCEDescriptorTypedef{ccptn,no_filename,ccptn_descriptor_invalid_pathname_t}


@deftp {Struct Typedef} @CCEConditionObjectType{ccptn,no_filename}
Type of data structure representing an exceptional--condition object.  It has the following public
fields:

@table @code
@item ccptn_condition_invalid_pathname_t invalid_pathname
Core values for the exceptional--condition object.
@end table
@end deftp


@CCEConditionObjectNewNoArgs{ccptn,no_filename}


@CCEConditionObjectPredicate{ccptn,no_filename}


@CCEConditionSubtypingFacilitiesNoArgsFailing{ccptn,no_filename}

@c page
@node conditions no tailname
@section Tailname is missing


The @dfn{no tailname exceptional--condition object--type} has the purpose of describing an exceptional
condition caused by attempting an operation on a pathname that has no tailname part, when this is
required.  The tailname is the relative pathname representing the last segment.  Examples:

@example
"/path/to/file.ext"     @result{} "file.ext"
"/path/to/dir/"         @result{} "dir/"
"file.ext"              @result{} "file.ext"
"."                     @result{} "."
".."                    @result{} ".."
"/"                     @error{} no tailname
@end example

All the following definitions are accessible from the header file @file{ccpathnames.h}.


@CCEDescriptorTypedef{ccptn,no_tailname,ccptn_descriptor_invalid_pathname_t}


@deftp {Struct Typedef} @CCEConditionObjectType{ccptn,no_tailname}
Type of data structure representing an exceptional--condition object.  It has the following public
fields:

@table @code
@item ccptn_condition_invalid_pathname_t invalid_pathname
Core values for the exceptional--condition object.
@end table
@end deftp


@CCEConditionObjectNewNoArgs{ccptn,no_tailname}


@CCEConditionObjectPredicate{ccptn,no_tailname}


@CCEConditionSubtypingFacilitiesNoArgsFailing{ccptn,no_tailname}

@c page
@node conditions no rootname
@section Rootname is missing


The @dfn{no rootname exceptional--condition object--type} has the purpose of describing an
exceptional condition caused by attempting an operation on a pathname that has no rootname part,
when this is required.  The rootname is a pathname with the extension of the last segment stripped.
Examples:

@example
"/path/to/file.ext"     @result{} "/path/to/file"
"/path/to/file"         @result{} "/path/to/file"
"/path/to/dir/"         @result{} "/path/to/dir"
"file.ext"              @result{} "file.ext"
".fvwmrc"               @result{} ".fvwmrc"
"."                     @error{} missing rootname
".."                    @error{} missing rootname
@end example

All the following definitions are accessible from the header file @file{ccpathnames.h}.


@CCEDescriptorTypedef{ccptn,no_rootname,ccptn_descriptor_invalid_pathname_t}


@deftp {Struct Typedef} @CCEConditionObjectType{ccptn,no_rootname}
Type of data structure representing an exceptional--condition object.  It has the following public
fields:

@table @code
@item ccptn_condition_invalid_pathname_t invalid_pathname
Core values for the exceptional--condition object.
@end table
@end deftp


@CCEConditionObjectNewNoArgs{ccptn,no_rootname}


@CCEConditionObjectPredicate{ccptn,no_rootname}


@CCEConditionSubtypingFacilitiesNoArgsFailing{ccptn,no_rootname}

@c page
@node typedefs
@chapter Type definitions


@deftp {Struct Typedef} ccptn_t
Structure representing a Unix pathname.  All the fields are opaque.  All the instances of this type
are immutable: their internal representation must not be mutated after construction.

The pathname is internally represented with an @asciiz{} string.  All the octets in the range
@math{[1, 255]} are valid for the pathname.  A pathname is never empty: it always contains at least
one octet.
@end deftp

@c page
@node handlers
@chapter Destroying pathname representations


@value{PACKAGE} is linked to the CCExceptions library to handle errors by raising exceptions; we can
use exception handlers to release @objtype{ccptn_t} instances upon exiting a local context.
@ccexceptionsref{handlers, The location handlers @api{}}.

@value{PACKAGE} implements some ``guarded'' constructors that internally use the macro
@cfunc{ccptn_init_and_register_handler} to appropriately register a pathname instance for
destruction.


@deftp {Struct Typedef} ccptn_clean_handler_t
@deftpx {Struct Typedef} ccptn_error_handler_t
Type of exception handlers we can use to destroy instances of @objtype{ccptn_t} using the facilities
of the library CCExceptions.
@end deftp


@deftypefun void ccptn_init_and_register_clean_handler (cce_destination_t @var{L}, ccptn_clean_handler_t * @var{H}, ccptn_t const * @var{P})
@deftypefunx void ccptn_init_and_register_error_handler (cce_destination_t @var{L}, ccptn_error_handler_t * @var{H}, ccptn_t const * @var{P})
Initialise the handler @var{H} to destroy the pathname @var{P} in the context of the location
@var{L}.
@end deftypefun


@deftypefn {Preprocessor Macro} void ccptn_init_and_register_handler (cce_destination_t @var{L}, @var{H}, ccptn_t const * @var{P})
Initialise the handler @var{H} to destroy the pathname @var{P} in the context of the location
@var{L}.  The expansion of this macro depends upon the type of @var{H}, if the type is:

@table @code
@item ccptn_clean_handler_t *
The macro expands into a call to @cfunc{ccptn_init_and_register_clean_handler}.

@item ccptn_error_handler_t *
The macro expands into a call to @cfunc{ccptn_init_and_register_error_handler}.
@end table
@end deftypefn

@c page
@node ctors
@chapter Constructing pathname representations


@menu
* ctors embedded::              Constructors for embedded instances.
* ctors standalone::            Constructors for standalone instances.
@end menu

@c page
@node ctors embedded
@section Constructors for embedded instances


An @dfn{embedded} instance of @objtype{ccptn_t} is allocated on the stack or embedded into an
enclosing data structure.  The constructors of such instances do not have to allocate memory for the
instance itself.

@menu
* ctors embedded pointers::     Constructors for embedded instances from
                                @asciiz{} pointers.
* ctors embedded asciiz::       Constructors for embedded instances from
                                @asciiz{} blocks.
* ctors embedded ascii::        Constructors for embedded instances from
                                @ascii{} blocks.
* ctors embedded deser::        Constructors for embedded instances from
                                deserialisation.
* ctors embedded clone::        Constructors for embedded instances from
                                cloning.
@end menu

@c page
@node ctors embedded pointers
@subsection Constructors for embedded instances from @asciiz{} pointers


@deftypefun void {ccname_init(ccptn_t, pointer)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_t * @var{P}, char const * @var{input_rep})
Initialise the already allocated @struct{} @var{P}, using the memory allocator @var{A}, and the
input representation @var{input_rep}.  When successful: just return.  If an error occurs: raise an
exception by performing a non--local exit to @var{L}.

The argument @var{input_rep} must reference an @asciiz{} string, which is referenced by the instance
of @objtype{ccptn_t}.

@example
cce_location_t             L[1];
ccptn_clean_handler_t      H[1];
ccmem_allocator_t const *  A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  char const *  input = "/path/to/file.ext";
  ccptn_t       P[1];

  ccname_init(ccptn_t, pointer)(L, A, P, input);
  ccptn_init_and_register_handler(L, H, P);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun void {ccname_init(ccptn_t, pointer, dup)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_t * @var{P}, char const * @var{input_rep})
Like @cfunc{ccname_init(ccptn_t, pointer)}, but duplicate the input representation @var{input_rep}.

@example
cce_location_t             L[1];
ccptn_clean_handler_t      H[1];
ccmem_allocator_t const *  A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  char const *  input = "/path/to/file.ext";
  ccptn_t       P[1];

  ccname_init(ccptn_t, pointer, dup)(L, A, P, input);
  ccptn_init_and_register_handler(L, H, P);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun void {ccname_init(ccptn_t, pointer, clean)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_clean_handler_t * @var{H}, ccptn_t * @var{P}, char const * @var{input_rep})
@deftypefunx void {ccname_init(ccptn_t, pointer, error)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_error_handler_t * @var{H}, ccptn_t * @var{P}, char const * @var{input_rep})
Like @cfunc{ccname_init(ccptn_t, pointer)} but register the pathname instance to be destroyed using
the handler @var{H} in the context of the location @var{L}.

@example
cce_location_t             L[1];
ccptn_clean_handler_t      H[1];
ccmem_allocator_t const *  A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  char const *  input = "/path/to/file.ext";
  ccptn_t       P[1];

  ccname_init(ccptn_t, pointer, clean)(L, A, H, P, input);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun void {ccname_init(ccptn_t, pointer, dup, clean)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_clean_handler_t * @var{H}, ccptn_t * @var{P}, char const * @var{input_rep})
@deftypefunx void {ccname_init(ccptn_t, pointer, dup, error)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_error_handler_t * @var{H}, ccptn_t * @var{P}, char const * @var{input_rep})
Like @cfunc{ccname_init(ccptn_t, pointer, dup)} but register the pathname instance to be destroyed
using the handler @var{H} in the context of the location @var{L}.

@example
cce_location_t             L[1];
ccptn_clean_handler_t      H[1];
ccmem_allocator_t const *  A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  char const *  input = "/path/to/file.ext";
  ccptn_t       P[1];

  ccname_init(ccptn_t, pointer, dup, clean)(L, A, H, P, input);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun

@c page
@node ctors embedded asciiz
@subsection Constructors for embedded instances from @asciiz{} blocks


@deftypefun void {ccname_init(ccptn_t, asciiz)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_t * @var{P}, ccmem_asciiz_t @var{input_rep})
Initialise the already allocated @struct{} @var{P}, using the memory allocator @var{A}, and the
input representation @var{input_rep}.  When successful: just return.  If an error occurs: raise an
exception by performing a non--local exit to @var{L}.

The argument @var{input_rep} must reference an @asciiz{} string, which is referenced by the instance
of @objtype{ccptn_t}; @ccmemoryref{ascii zero, Zero terminated strings}.

@example
cce_location_t             L[1];
ccptn_clean_handler_t      H[1];
ccmem_allocator_t const *  A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  ccmem_asciiz_t  input = \
    ccmem_new_asciiz_from_str("/path/to/file.ext");
  ccptn_t         P[1];

  ccname_init(ccptn_t, asciiz)(L, A, P, input);
  ccptn_init_and_register_handler(L, H, P);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun void {ccname_init(ccptn_t, asciiz, dup)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_t * @var{P}, ccmem_asciiz_t @var{input_rep})
Like @cfunc{ccname_init(ccptn_t, asciiz)}, but duplicate the input representation
@var{input_rep}.

@example
cce_location_t             L[1];
ccptn_clean_handler_t      H[1];
ccmem_allocator_t const *  A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  ccmem_asciiz_t  input = \
    ccmem_new_asciiz_from_str("/path/to/file.ext");
  ccptn_t       P[1];

  ccname_init(ccptn_t, asciiz, dup)(L, A, P, input);
  ccptn_init_and_register_handler(L, H, P);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun void {ccname_init(ccptn_t, asciiz, clean)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_clean_handler_t * @var{H}, ccptn_t * @var{P}, ccmem_asciiz_t @var{input_rep})
@deftypefunx void {ccname_init(ccptn_t, asciiz, error)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_error_handler_t * @var{H}, ccptn_t * @var{P}, ccmem_asciiz_t @var{input_rep})
Like @cfunc{ccname_init(ccptn_t, asciiz)} but register the pathname instance to be destroyed using
the handler @var{H} in the context of the location @var{L}.

@example
cce_location_t             L[1];
ccptn_clean_handler_t      H[1];
ccmem_allocator_t const *  A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  ccmem_asciiz_t  input = \
    ccmem_new_asciiz_from_str("/path/to/file.ext");
  ccptn_t         P[1];

  ccname_init(ccptn_t, asciiz, clean)(L, A, H, P, input);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun void {ccname_init(ccptn_t, asciiz, dup, clean)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_clean_handler_t * @var{H}, ccptn_t * @var{P}, ccmem_asciiz_t @var{input_rep})
@deftypefunx void {ccname_init(ccptn_t, asciiz, dup, error)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_error_handler_t * @var{H}, ccptn_t * @var{P}, ccmem_asciiz_t @var{input_rep})
Like @cfunc{ccname_init(ccptn_t, asciiz, dup)} but register the pathname instance to be destroyed
using the handler @var{H} in the context of the location @var{L}.

@example
cce_location_t             L[1];
ccptn_clean_handler_t      H[1];
ccmem_allocator_t const *  A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  ccmem_asciiz_t  input = \
    ccmem_new_asciiz_from_str("/path/to/file.ext");
  ccptn_t         P[1];

  ccname_init(ccptn_t, asciiz, dup, clean)(L, A, H, P, input);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun

@c page
@node ctors embedded ascii
@subsection Constructors for embedded instances from @ascii{} blocks


@deftypefun void {ccname_init(ccptn_t, ascii)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_t * @var{P}, ccmem_ascii_t @var{input_rep})
@deftypefunx void {ccname_init(ccptn_t, ascii, dup)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_t * @var{P}, ccmem_ascii_t @var{input_rep})
Initialise the already allocated @struct{} @var{P}, using the memory allocator @var{A}, and the
input representation @var{input_rep}.  When successful: just return.  If an error occurs: raise an
exception by performing a non--local exit to @var{L}.

The argument @var{input_rep} must reference an @ascii{} string, which is duplicated by the instance
of @objtype{ccptn_t}; @ccmemoryref{ascii non-zero, Non--zero terminated strings}.

@example
cce_location_t             L[1];
ccptn_clean_handler_t      H[1];
ccmem_allocator_t const *  A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  ccmem_ascii_t  input = \
    ccmem_new_ascii_from_str("/path/to/file.ext");
  ccptn_t         P[1];

  ccname_init(ccptn_t, ascii)(L, A, P, input);
  ccptn_init_and_register_handler(L, H, P);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun void {ccname_init(ccptn_t, ascii, clean)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_clean_handler_t * @var{H}, ccptn_t * @var{P}, ccmem_ascii_t @var{input_rep})
@deftypefunx void {ccname_init(ccptn_t, ascii, error)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_error_handler_t * @var{H}, ccptn_t * @var{P}, ccmem_ascii_t @var{input_rep})
@deftypefunx void {ccname_init(ccptn_t, ascii, dup, clean)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_clean_handler_t * @var{H}, ccptn_t * @var{P}, ccmem_ascii_t @var{input_rep})
@deftypefunx void {ccname_init(ccptn_t, ascii, dup, error)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_error_handler_t * @var{H}, ccptn_t * @var{P}, ccmem_ascii_t @var{input_rep})
Like @cfunc{ccname_init(ccptn_t, ascii)} but register the pathname instance to be destroyed using
the handler @var{H} in the context of the location @var{L}.

@example
cce_location_t             L[1];
ccptn_clean_handler_t      H[1];
ccmem_allocator_t const *  A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  ccmem_ascii_t  input = \
    ccmem_new_ascii_from_str("/path/to/file.ext");
  ccptn_t        P[1];

  ccname_init(ccptn_t, ascii, clean)(L, A, H, P, input);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun

@c page
@node ctors embedded deser
@subsection Constructors for embedded instances from deserialisation


The @trait{deserialiser} trait allows us to construct an instance of @objtype{ccptn_t} by
reading the internal representation from storage memory.  @ref{traits deserialiser, The
@trait{deserialiser} trait}.


@deftypefun void {ccname_init(ccptn_t, deserialisable)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_t * @var{P})
Initialise an already allocated @objtype{ccptn_t}, referenced by @var{P}, in such a way that it can
be used as target for deserialisation using the @trait{deserialiser} trait; use the allocator
@var{A}.  When successful just return.  If an error occurs: raise an exception by performing a
non--local exit to @var{L}.

Whether the initialised instance is used for deserialisation or not: we can always finalise it using
a @trait{dtor} trait or a destruction handler.

@example
cce_location_t             L[1];
ccptn_clean_handler_t      H[1];
ccmem_allocator_t const *  A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  ccptn_t  P[1];

  ccname_init(ccptn_t, deserialisable)(L, A, P);
  ccptn_init_and_register_handler(L, H, P);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun void {ccname_init(ccptn_t, deserialisable, clean)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_clean_handler_t * @var{H}, ccptn_t * @var{P})
@deftypefunx void {ccname_init(ccptn_t, deserialisable, error)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_error_handler_t * @var{H}, ccptn_t * @var{P})
Like @cfunc{ccname_init(ccptn_t, deserialisable)} but register the pathname instance to be destroyed
using the handler @var{H} in the context of the location @var{L}.

@example
cce_location_t             L[1];
ccptn_clean_handler_t      H[1];
ccmem_allocator_t const *  A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  ccptn_t  P[1];

  ccname_init(ccptn_t, deserialisable, clean)(L, A, H, P);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun

@c page
@node ctors embedded clone
@subsection Constructors for embedded instances from cloning


@deftypefun void {ccname_init(ccptn_t, clone)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_t * @var{dst}, ccptn_t const * @var{src})
Initialise an already allocated @objtype{ccptn_t}, referenced by @var{dst}, cloning the pathname
@var{src}; use the allocator @var{A}.  When successful just return.  If an error occurs: raise an
exception by performing a non--local exit to @var{L}.

@example
cce_location_t             L[1];
ccptn_clean_handler_t      dst_H[1], src_H[1];
ccmem_allocator_t const *  A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  char const  *input = "/path/to/file.ext";
  ccptn_t     dst[1], src[1];

  ccname_init(ccptn_t, pointer, clean)(L, A, src_H, src, input);
  ccname_init(ccptn_t, clone)(L, A, dst, src);
  ccptn_init_and_register_handler(L, dst_H, dst);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun void {ccname_init(ccptn_t, clone, clean)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_clean_handler_t * @var{H}, ccptn_t * @var{dst}, ccptn_t * @var{src})
@deftypefunx void {ccname_init(ccptn_t, clone, error)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_error_handler_t * @var{H}, ccptn_t * @var{dst}, ccptn_t * @var{src})
Like @cfunc{ccname_init(ccptn_t, clone)} but register the pathname instance to be destroyed using
the handler @var{H} in the context of the location @var{L}.

@example
cce_location_t             L[1];
ccptn_clean_handler_t      dst_H[1], src_H[1];
ccmem_allocator_t const *  A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  char const  *input = "/path/to/file.ext";
  ccptn_t     dst[1], src[1];

  ccname_init(ccptn_t, pointer, clean)(L, A, src_H, src, input);
  ccname_init(ccptn_t, clone,   clean)(L, A, dst_H, dst, src);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun

@c page
@node ctors standalone
@section Constructors for standalone instances


A @dfn{standalone} instance of @objtype{ccptn_t} is allocated on the heap.  The constructors of such
instances do have to allocate memory for the instance itself.

@menu
* ctors standalone pointers::   Constructors for standalone instances from
                                @asciiz{} pointers.
* ctors standalone asciiz::     Constructors for standalone instances from
                                @asciiz{} blocks.
* ctors standalone ascii::      Constructors for standalone instances from
                                @ascii{} blocks.
* ctors standalone deser::      Constructors for standalone instances from
                                deserialisation.
* ctors standalone clone::      Constructors for standalone instances from
                                cloning.
@end menu

@c page
@node ctors standalone pointers
@subsection Constructors for standalone instances from @asciiz{} pointers


@deftypefun {ccptn_t const *} {ccname_new(ccptn_t, pointer)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, char const * @var{input_rep})
Allocate a new instance of @objtype{ccptn_t}, using the memory allocator @var{A}, and the input
representation @var{input_rep}.  When successful: just return.  If an error occurs: raise an
exception by performing a non--local exit to @var{L}.

The argument @var{input_rep} must reference an @asciiz{} string, which is referenced by the instance
of @objtype{ccptn_t}.

@example
cce_location_t             L[1];
ccptn_clean_handler_t      H[1];
ccmem_allocator_t const *  A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  char const *     input = "/path/to/file.ext";
  ccptn_t const *  P;

  P = ccname_new(ccptn_t, pointer)(L, A, input);
  ccptn_init_and_register_handler(L, H, P);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun {ccptn_t const *} {ccname_new(ccptn_t, pointer, dup)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, char const * @var{input_rep})
Like @cfunc{ccname_new(ccptn_t, pointer)}, but duplicate the input representation @var{input_rep}.

@example
cce_location_t             L[1];
ccptn_clean_handler_t      H[1];
ccmem_allocator_t const *  A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  char const *     input = "/path/to/file.ext";
  ccptn_t const *  P;

  P = ccname_new(ccptn_t, pointer, dup)(L, A, input);
  ccptn_init_and_register_handler(L, H, P);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun {ccptn_t const *} {ccname_new(ccptn_t, pointer, clean)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_clean_handler_t * @var{H}, char const * @var{input_rep})
@deftypefunx {ccptn_t const *} {ccname_new(ccptn_t, pointer, error)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_error_handler_t * @var{H}, char const * @var{input_rep})
Like @cfunc{ccname_new(ccptn_t, pointer)} but register the pathname instance to be destroyed using
the handler @var{H} in the context of the location @var{L}.

@example
cce_location_t             L[1];
ccptn_clean_handler_t      H[1];
ccmem_allocator_t const *  A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  char const *     input = "/path/to/file.ext";
  ccptn_t const *  P;

  P = ccname_new(ccptn_t, pointer, clean)(L, A, H, input);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun {ccptn_t const *} {ccname_new(ccptn_t, pointer, dup, clean)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_clean_handler_t * @var{H}, char const * @var{input_rep})
@deftypefunx {ccptn_t const *} {ccname_new(ccptn_t, pointer, dup, error)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_error_handler_t * @var{H}, char const * @var{input_rep})
Like @cfunc{ccname_new(ccptn_t, pointer, dup)} but register the pathname instance to be destroyed
using the handler @var{H} in the context of the location @var{L}.

@example
cce_location_t             L[1];
ccptn_clean_handler_t      H[1];
ccmem_allocator_t const *  A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  char const *     input = "/path/to/file.ext";
  ccptn_t const *  P;

  P = ccname_new(ccptn_t, pointer, dup, clean)(L, A, H, input);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun

@c page
@node ctors standalone asciiz
@subsection Constructors for standalone instances from @asciiz{} blocks


@deftypefun {ccptn_t const *} {ccname_new(ccptn_t, asciiz)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccmem_asciiz_t @var{input_rep})
Allocate a new instance of @objtype{ccptn_t}, using the memory allocator @var{A}, and the input
representation @var{input_rep}.  When successful: just return.  If an error occurs: raise an
exception by performing a non--local exit to @var{L}.

The argument @var{input_rep} must reference an @asciiz{} string, which is referenced by the instance
of @objtype{ccptn_t}; @ccmemoryref{ascii zero, Zero terminated strings}.

@example
cce_location_t             L[1];
ccptn_clean_handler_t      H[1];
ccmem_allocator_t const *  A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  ccmem_asciiz_t  input = \
    ccmem_new_asciiz_from_str("/path/to/file.ext");
  ccptn_t const * P;

  P = ccname_new(ccptn_t, asciiz)(L, A, input);
  ccptn_init_and_register_handler(L, H, P);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun {ccptn_t const *} {ccname_new(ccptn_t, asciiz, dup)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccmem_asciiz_t @var{input_rep})
Like @cfunc{ccname_new(ccptn_t, asciiz, dup)}, but duplicate the input representation
@var{input_rep}.

@example
cce_location_t             L[1];
ccptn_clean_handler_t      H[1];
ccmem_allocator_t const *  A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  ccmem_asciiz_t  input = \
    ccmem_new_asciiz_from_str("/path/to/file.ext");
  ccptn_t const * P;

  P = ccname_new(ccptn_t, asciiz, dup)(L, A, input);
  ccptn_init_and_register_handler(L, H, P);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun {ccptn_t const *} {ccname_new(ccptn_t, asciiz, clean)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_clean_handler_t * @var{H}, char const * @var{input_rep})
@deftypefunx {ccptn_t const *} {ccname_new(ccptn_t, asciiz, error)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_error_handler_t * @var{H}, char const * @var{input_rep})
Like @cfunc{ccname_new(ccptn_t, asciiz)} but register the pathname instance to be destroyed using
the handler @var{H} in the context of the location @var{L}.

@example
cce_location_t             L[1];
ccptn_clean_handler_t      H[1];
ccmem_allocator_t const *  A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  ccmem_asciiz_t   input = \
    ccmem_new_asciiz_from_str("/path/to/file.ext");
  ccptn_t const *  P;

  P = ccname_new(ccptn_t, asciiz, clean)(L, A, H, input);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun {ccptn_t const *} {ccname_new(ccptn_t, asciiz, dup, clean)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_clean_handler_t * @var{H}, char const * @var{input_rep})
@deftypefunx {ccptn_t const *} {ccname_new(ccptn_t, asciiz, dup, error)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_error_handler_t * @var{H}, char const * @var{input_rep})
Like @cfunc{ccname_new(ccptn_t, asciiz, dup)} but register the pathname instance to be destroyed
using the handler @var{H} in the context of the location @var{L}.

@example
cce_location_t             L[1];
ccptn_clean_handler_t      H[1];
ccmem_allocator_t const *  A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  ccmem_asciiz_t   input = \
    ccmem_new_asciiz_from_str("/path/to/file.ext");
  ccptn_t const *  P;

  P = ccname_new(ccptn_t, asciiz, dup, clean)(L, A, H, input);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun

@c page
@node ctors standalone ascii
@subsection Constructors for standalone instances from @ascii{} blocks


@deftypefun {ccptn_t const *} {ccname_new(ccptn_t, ascii)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccmem_ascii_t @var{input_rep})
@deftypefunx {ccptn_t const *} {ccname_new(ccptn_t, ascii, dup)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccmem_ascii_t @var{input_rep})
Allocate a new instance of @objtype{ccptn_t}, using the memory allocator @var{A}, and the input
representation @var{input_rep}.  When successful: just return.  If an error occurs: raise an
exception by performing a non--local exit to @var{L}.

The argument @var{input_rep} must reference an @ascii{} string, which is duplicated by the instance
of @objtype{ccptn_t}; @ccmemoryref{ascii non-zero, Non--zero terminated strings}.

@example
cce_location_t             L[1];
ccptn_clean_handler_t      H[1];
ccmem_allocator_t const *  A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  ccmem_ascii_t   input = \
    ccmem_new_ascii_from_str("/path/to/file.ext");
  ccptn_t const * P;

  P = ccname_new(ccptn_t, ascii)(L, A, input);
  ccptn_init_and_register_handler(L, H, P);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun {ccptn_t const *} {ccname_new(ccptn_t, ascii, clean)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_clean_handler_t * @var{H}, char const * @var{input_rep})
@deftypefunx {ccptn_t const *} {ccname_new(ccptn_t, ascii, error)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_error_handler_t * @var{H}, char const * @var{input_rep})
@deftypefunx {ccptn_t const *} {ccname_new(ccptn_t, ascii, dup, clean)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_clean_handler_t * @var{H}, char const * @var{input_rep})
@deftypefunx {ccptn_t const *} {ccname_new(ccptn_t, ascii, dup, error)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_error_handler_t * @var{H}, char const * @var{input_rep})
Like @cfunc{ccname_new(ccptn_t, ascii)} but register the pathname instance to be destroyed using
the handler @var{H} in the context of the location @var{L}.

@example
cce_location_t             L[1];
ccptn_clean_handler_t      H[1];
ccmem_allocator_t const *  A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  ccmem_ascii_t   input = \
    ccmem_new_ascii_from_str("/path/to/file.ext");
  ccptn_t const *  P;

  P = ccname_new(ccptn_t, ascii, clean)(L, A, H, input);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun

@c page
@node ctors standalone deser
@subsection Constructors for standalone instances from deserialisation


The @trait{deserialiser} trait allows us to construct an instance of @objtype{ccptn_t} by
reading the internal representation from storage memory.  @ref{traits deserialiser, The
@trait{deserialiser} trait}.


@deftypefun {ccptn_t const *} {ccname_new(ccptn_t, deserialisable)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A})
Build a newly allocated instance of @objtype{ccptn_t}, in such a way that it can be used as target
for deserialisation using the @trait{deserialiser} trait; use the allocator @var{A}.  When
successful return a pointer to the new instance.  If an error occurs: raise an exception by
performing a non--local exit to @var{L}.

Whether the initialised instance is used for deserialisation or not: we can always finalise it using
a @trait{dtor} trait or a destruction handler.

@example
cce_location_t             L[1];
ccptn_clean_handler_t      H[1];
ccmem_allocator_t const *  A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  ccptn_t const  *P;

  P = ccname_new(ccptn_t, deserialisable)(L, A);
  ccptn_init_and_register_handler(L, H, P);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun {ccptn_t const *} {ccname_new(ccptn_t, deserialisable, clean)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_clean_handler_t * @var{H})
@deftypefunx {ccptn_t const *} {ccname_new(ccptn_t, deserialisable, error)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_error_handler_t * @var{H})
Like @cfunc{ccname_new(ccptn_t, deserialisable)} but register the pathname instance to be destroyed
using the handler @var{H} in the context of the location @var{L}.

@example
cce_location_t             L[1];
ccptn_clean_handler_t      H[1];
ccmem_allocator_t const *  A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  ccptn_t const  *P;

  P = ccname_new(ccptn_t, deserialisable, clean)(L, A, H);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun

@c page
@node ctors standalone clone
@subsection Constructors for standalone instances from cloning


@deftypefun {ccptn_t const *} {ccname_new(ccptn_t, clone)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_t const * @var{src})
Build a new instance of @objtype{ccptn_t} cloning the pathname @var{src}; use the allocator @var{A}.
When successful just return.  If an error occurs: raise an exception by performing a non--local exit
to @var{L}.

@example
cce_location_t             L[1];
ccptn_clean_handler_t      dst_H[1], src_H[1];
ccmem_allocator_t const *  A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  char const     *input = "/path/to/file.ext";
  ccptn_t const  *dst, *src];

  src = ccname_new(ccptn_t, pointer, clean)(L, A, src_H, input);
  dst = ccname_new(ccptn_t, clone)(L, A, src);
  ccptn_init_and_register_handler(L, dst_H, dst);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun {ccptn_t const *} {ccname_new(ccptn_t, clone, clean)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_clean_handler_t * @var{H}, ccptn_t * @var{src})
@deftypefunx {ccptn_t const *} {ccname_new(ccptn_t, clone, error)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_error_handler_t * @var{H}, ccptn_t * @var{src})
Like @cfunc{ccname_new(ccptn_t, clone)} but register the pathname instance to be destroyed using the
handler @var{H} in the context of the location @var{L}.

@example
cce_location_t             L[1];
ccptn_clean_handler_t      dst_H[1], src_H[1];
ccmem_allocator_t const *  A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_raise(L, upper_L);
@} else @{
  char const     *input = "/path/to/file.ext";
  ccptn_t const  *dst, *src];

  src = ccname_new(ccptn_t, pointer, clean)(L, A, src_H, input);
  dst = ccname_new(ccptn_t, clone,   clean)(L, A, dst_H, src);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun

@c page
@node predicates
@chapter Pathname predicates


@deftypefun bool ccptn_is_absolute (ccptn_t const * @var{P})
Return @ctrue{} if @var{P} represents an absolute pathname; otherwise return @cfalse{}.  A pathname
is absolute if its first octet is the @ascii{} representation of @samp{/}.
@end deftypefun


@deftypefun bool ccptn_is_relative (ccptn_t const * @var{P})
Return @ctrue{} if @var{P} represents a relative pathname; otherwise return @cfalse{}.  A pathname
is relative if its first octet is @strong{not} the @ascii{} representation of @samp{/}.
@end deftypefun


@deftypefun bool ccptn_is_realpath (ccptn_t const * @var{P})
Return @ctrue{} if @var{P} is the result of a call to the system function @cfunc{realpath};
otherwise return @cfalse{}.  @glibcref{Symbolic Links, realpath}.
@end deftypefun


@deftypefun bool ccptn_is_normalised (ccptn_t const * @var{P})
Return @ctrue{} if @var{P} is the result of either a call to the system function @cfunc{realpath} or
to one of the normalisation functions; otherwise return @cfalse{}.
@end deftypefun

@c page
@node accessors
@chapter Pathname accessors


@deftypefun {char const *} ccptn_ptr (ccptn_t const * @var{P})
Return a pointer to an @asciiz{} representation of the pathname.
@end deftypefun


@deftypefun size_t ccptn_len (ccptn_t const * @var{P})
Return the number of octets in the pathname representation, @strong{not} including the terminating
zero.
@end deftypefun


@deftypefun ccmem_ascii_t ccptn_ascii (ccptn_t const * @var{P})
Return an @ascii{} block referencing the pathname representation; @ccmemoryref{ascii non-zero,
Non--zero terminated strings}.
@end deftypefun


@deftypefun ccmem_asciiz_t ccptn_asciiz (ccptn_t const * @var{P})
Return an @asciiz{} block referencing the pathname representation; @ccmemoryref{ascii zero, Zero
terminated strings}.
@end deftypefun


@deftypefun ccmem_block_t ccptn_block (ccptn_t const * @var{P})
Return a block referencing the pathname representation; @ccmemoryref{blocks, Blocks of memory}.  The
pointer of the block references an @asciiz{} representation of the pathname; the length of the block
represents the number of octets in the pathname representation, @strong{including} the terminating
zero.
@end deftypefun


@deftypefun {ccmem_allocator_t const *} ccptn_allocator (ccptn_t const * @var{P})
Return the memory allocator; @ccmemoryref{allocators typedefs, Type definitions}.
@end deftypefun

@c page
@node manipulations
@chapter Pathname manipulations


@menu
* manipulations realpath::      Obtaining the real pathname.
* manipulations normalise::     Normalising pathnames.
* manipulations concat::        Concatenating pathnames.
@end menu

@c page
@node manipulations realpath
@section Obtaining the real pathname


@menu
* manipulations realpath embedded::     Obtaining an embedded real pathname.
* manipulations realpath standalone::   Obtaining a standalone real pathname.
@end menu

@c page
@node manipulations realpath embedded
@subsection Obtaining an embedded real pathname


An @dfn{embedded} instance of @objtype{ccptn_t} is allocated on the stack or embedded into an
enclosing data structure.  The constructors of such instances do not have to allocate memory for the
instance itself.


@deftypefun void {ccname_init(ccptn_t, realpath)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_t * @var{dst}, ccptn_t const * @var{src})
Initialise the already allocated @objtype{ccptn_t} instance, referenced by @var{dst}, representing
the result of applying the standard @cfunc{realpath} to the pathname represented by @var{src}; use
the allocator @var{A}.  When successful: just return.  If an error occurs: raise an exception by
performing a non--local exit to to @var{L}.

Notice that the pathname has to exist for this function to succeed.

@example
cce_location_t           L[1];
ccptn_clean_handler_t    P_H[1], Q_H[1];
ccmem_allocator_t const  *A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const  *input = "/path/to/file.ext";
  ccptn_t     P[1], R[1];

  ccname_init(ccptn_t, pointer, clean)(L, A, P_H, P, input);
  ccname_init(ccptn_t, realpath)(L, A, R, P);
  ccptn_init_and_register_handler(L, R_H, R);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun void {ccname_init(ccptn_t, realpath, clean)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_clean_handler_t * @var{H}, ccptn_t * @var{dst}, ccptn_t const * @var{src})
@deftypefunx void {ccname_init(ccptn_t, realpath, error)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_error_handler_t * @var{H}, ccptn_t * @var{dst}, ccptn_t const * @var{src})
Like @cfunc{ccname_init(ccptn_t, realpath)} but register the pathname instance to be destroyed using
the handler @var{H} in the context of the location @var{L}.

@example
cce_location_t           L[1];
ccptn_clean_handler_t    P_H[1], Q_H[1];
ccmem_allocator_t const  *A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const  *input = "/path/to/file.ext";
  ccptn_t     P[1], R[1];

  ccname_init(ccptn_t, pointer,  clean)(L, A, P_H, P, input);
  ccname_init(ccptn_t, realpath, clean)(L, A, R_H, R, P);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun

@c page
@node manipulations realpath standalone
@subsection Obtaining a standalone real pathname


A @dfn{standalone} instance of @objtype{ccptn_t} is allocated on the heap.  The constructors of such
instances do have to allocate memory for the instance itself.


@deftypefun {ccptn_t const *} {ccname_new(ccptn_t, realpath)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_t const * @var{src})
Build and return a new @objtype{ccptn_t} instance representing the result of applying the standard
@cfunc{realpath} to the pathname represented by @var{src}; use the allocator @var{A}.  When
successful: return a pointer to the new instance.  If an error occurs: raise an exception by
performing a non--local exit to to @var{L}.

Notice that the pathname has to exist for this function to succeed.

@example
cce_location_t             L[1];
ccptn_clean_handler_t      P_H[1], Q_H[1];
ccmem_allocator_t const *  A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const     *input = "/path/to/file.ext";
  ccptn_t const  *P, *Q;

  P = ccname_new(ccptn_t, pointer, clean)(L, A, P_H, input);
  Q = ccname_new(ccptn_t, realpath)(L, A, P);
  ccptn_init_and_register_handler(L, Q_H, Q);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun {ccptn_t const *} {ccname_new(ccptn_t, realpath, clean)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_clean_handler_t * @var{H}, ccptn_t const * @var{src})
@deftypefunx {ccptn_t const *} {ccname_new(ccptn_t, realpath, error)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_error_handler_t * @var{H}, ccptn_t const * @var{src})
Like @cfunc{ccname_new(ccptn_t, realpath)} but register the pathname instance to be destroyed using
the handler @var{H} in the context of the location @var{L}.

@example
cce_location_t           L[1];
ccptn_clean_handler_t    P_H[1], Q_H[1];
ccmem_allocator_t const  *A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const     *input = "/path/to/file.ext";
  ccptn_t const  *P, *R;

  P = ccname_init(ccptn_t, pointer,  clean)(L, A, P_H, input);
  Q = ccname_init(ccptn_t, realpath, clean)(L, A, R_H, P);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun

@c page
@node manipulations normalise
@section Normalising pathnames


A normalised pathname: has no multiple slashes; has no useless terminating slash; has no useless
single--dot components; has the double--dot components removed as much as possible.  Examples:

@example
/                       @result{} /
file.ext                @result{} file.ext
/path/to/file.ext       @result{} /path/to/file.ext
//                      @result{} /
/path///to///file.ext   @result{} /path/to/file.ext
/path/to/dir/           @result{} /path/to/dir/
/path/to/././file.ext   @result{} /path/to/file.ext
/path/to/.              @result{} /path/to
/path/to/../file.ext    @result{} /path/file.ext
/path/../../to/file.ext @result{} ../to/file.ext
.                       @result{} .
..                      @result{} ..
./                      @result{} .
../                     @result{} ..
/.                      @result{} /
/..                     @error{} invalid pathname
@end example

Some notes on the normalisation:

@itemize
@item
We do not want to remove an ending slash octet, unless the whole pathname is @file{./} or
@file{../}.  This is because a pathname like @file{a/b/} is meant to represent a directory, while
@file{a/b} can represent a non--directory too.

@item
We do not want to fully remove a directory part.  This is because @file{./file.ext} may represent an
executable file in the current directory, while @file{file.ext} may represent an executable pathname
in any of the directories selected by the value in the environment variable @env{PATH}.  So we want
the following normalisations:

@example
./file.ext              @result{} ./file.ext
../path/file.ext        @result{} ./file.ext
@end example
@end itemize

@menu
* manipulations normalise embedded::    Obtaining a normalised embedded
                                        pathname.
* manipulations normalise standalone::  Obtaining a normalised standalone
                                        pathname.
@end menu

@c page
@node manipulations normalise embedded
@subsection Obtaining a normalised embedded pathname


An @dfn{embedded} instance of @objtype{ccptn_t} is allocated on the stack or embedded into an
enclosing data structure.  The constructors of such instances do not have to allocate memory for the
instance itself.


@deftypefun void {ccname_init(ccptn_t, normalise)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_t * @var{dst}, ccptn_t const * @var{src})
Initialise the already allocated @objtype{ccptn_t} instance, referenced by @var{dst}, representing
the result of normalising the pathname represented by @var{src}; use the allocator @var{A}.  When
successful: just return.  If an error occurs: raise an exception by performing a non--local exit to
to @var{L}.

Notice that this function will succeed even when the pathname @strong{does not} exist.

@example
cce_location_t           L[1];
ccptn_clean_handler_t    P_H[1], Q_H[1];
ccmem_allocator_t const  *A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const  *input = "/path/to/file.ext";
  ccptn_t     P[1], R[1];

  ccname_init(ccptn_t, pointer, clean)(L, A, P_H, P, input);
  ccname_init(ccptn_t, normalise)(L, A, R, P);
  ccptn_init_and_register_handler(L, R_H, R);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun void {ccname_init(ccptn_t, normalise, clean)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_clean_handler_t * @var{H}, ccptn_t * @var{dst}, ccptn_t const * @var{src})
@deftypefunx void {ccname_init(ccptn_t, normalise, error)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_error_handler_t * @var{H}, ccptn_t * @var{dst}, ccptn_t const * @var{src})
Like @cfunc{ccname_init(ccptn_t, normalise)} but register the pathname instance to be destroyed
using the handler @var{H} in the context of the location @var{L}.

@example
cce_location_t           L[1];
ccptn_clean_handler_t    P_H[1], Q_H[1];
ccmem_allocator_t const  *A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const  *input = "/path/to/file.ext";
  ccptn_t     P[1], R[1];

  ccname_init(ccptn_t, pointer,   clean)(L, A, P_H, P, input);
  ccname_init(ccptn_t, normalise, clean)(L, A, R_H, R, P);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun

@c page
@node manipulations normalise standalone
@subsection Obtaining a normalised standalone pathname


A @dfn{standalone} instance of @objtype{ccptn_t} is allocated on the heap.  The constructors of such
instances do have to allocate memory for the instance itself.


@deftypefun {ccptn_t const *} {ccname_new(ccptn_t, normalise)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_t const * @var{src})
Build and return a new @objtype{ccptn_t} instance representing the result of normalising the
pathname represented by @var{src}; use the allocator @var{A}.  When successful: return a pointer to
the new instance.  If an error occurs: raise an exception by performing a non--local exit to to
@var{L}.

Notice that this function will succeed even when the pathname @strong{does not} exist.

@example
cce_location_t             L[1];
ccptn_clean_handler_t      P_H[1], Q_H[1];
ccmem_allocator_t const *  A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const     *input = "/path/to/file.ext";
  ccptn_t const  *P, *Q;

  P = ccname_new(ccptn_t, pointer, clean)(L, A, P_H, input);
  Q = ccname_new(ccptn_t, normalise)(L, A, P);
  ccptn_init_and_register_handler(L, Q_H, Q);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun {ccptn_t const *} {ccname_new(ccptn_t, normalise, clean)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_clean_handler_t * @var{H}, ccptn_t const * @var{src})
@deftypefunx {ccptn_t const *} {ccname_new(ccptn_t, normalise, error)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_error_handler_t * @var{H}, ccptn_t const * @var{src})
Like @cfunc{ccname_new(ccptn_t, normalise)} but register the pathname instance to be destroyed using
the handler @var{H} in the context of the location @var{L}.

@example
cce_location_t           L[1];
ccptn_clean_handler_t    P_H[1], Q_H[1];
ccmem_allocator_t const  *A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const     *input = "/path/to/file.ext";
  ccptn_t const  *P, *R;

  P = ccname_init(ccptn_t, pointer,  clean)(L, A, P_H, input);
  Q = ccname_init(ccptn_t, normalise, clean)(L, A, R_H, P);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun

@c page
@node manipulations concat
@section Concatenating pathnames


@menu
* manipulations concat embedded::    Concatenating into an embedded
                                     pathname.
* manipulations concat standalone::  Concatenating into a standalone
                                     pathname.
@end menu

@c page
@node manipulations concat embedded
@subsection Concatenating into an embedded pathname


An @dfn{embedded} instance of @objtype{ccptn_t} is allocated on the stack or embedded into an
enclosing data structure.  The constructors of such instances do not have to allocate memory for the
instance itself.


@deftypefun void {ccname_init(ccptn_t, concat)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_t * @var{dst}, ccptn_t const * @var{prefix}, ccptn_t const * @var{suffix})
Initialise the already allocated @objtype{ccptn_t} instance, referenced by @var{dst}, representing
the result of concatenating the pathname represented by @var{prefix} and @var{suffix}; use the
allocator @var{A}.  When successful: just return.  If an error occurs: raise an exception by
performing a non--local exit to to @var{L}.

@example
cce_location_t           L[1];
ccptn_clean_handler_t    R_H[1], P_H[1], S_H[1];
ccmem_allocator_t const  *A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const  *input_prefix = "/path/to";
  char const  *input_suffix = "file.ext";
  ccptn_t     R[1], P[1], S[1];

  ccname_init(ccptn_t, pointer, clean)(L, A, P_H, P, input_prefix);
  ccname_init(ccptn_t, pointer, clean)(L, A, S_H, S, input_suffix);
  ccname_init(ccptn_t, concat)(L, A, R, P, S);
  ccptn_init_and_register_handler(L, R_H, R);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun void {ccname_init(ccptn_t, concat, clean)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_clean_handler_t * @var{H}, ccptn_t * @var{dst}, ccptn_t const * @var{prefix}, ccptn_t const * @var{suffix})
@deftypefunx void {ccname_init(ccptn_t, concat, error)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_error_handler_t * @var{H}, ccptn_t * @var{dst}, ccptn_t const * @var{prefix}, ccptn_t const * @var{suffix})
Like @cfunc{ccname_init(ccptn_t, concat)} but register the pathname instance to be destroyed using
the handler @var{H} in the context of the location @var{L}.

@example
cce_location_t           L[1];
ccptn_clean_handler_t    R_H[1], P_H[1], S_H[1];
ccmem_allocator_t const  *A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const  *input_prefix = "/path/to";
  char const  *input_suffix = "file.ext";
  ccptn_t     R[1], P[1], S[1];

  ccname_init(ccptn_t, pointer, clean)(L, A, P_H, P, input_prefix);
  ccname_init(ccptn_t, pointer, clean)(L, A, S_H, S, input_suffix);
  ccname_init(ccptn_t, concat,  clean)(L, A, R_H, R, P, S);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun

@c page
@node manipulations concat standalone
@subsection Concatenating into a standalone pathname


A @dfn{standalone} instance of @objtype{ccptn_t} is allocated on the heap.  The constructors of such
instances do have to allocate memory for the instance itself.


@deftypefun {ccptn_t const *} {ccname_new(ccptn_t, concat)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_t const * @var{prefix}, ccptn_t const * @var{suffix})
Build a new @objtype{ccptn_t} instance, arepresenting the result of concatenating the pathname
represented by @var{prefix} and @var{suffix}; use the allocator @var{A}.  When successful: return a
pointer to the new instance.  If an error occurs: raise an exception by performing a non--local exit
to to @var{L}.

@example
cce_location_t           L[1];
ccptn_clean_handler_t    R_H[1], P_H[1], S_H[1];
ccmem_allocator_t const  *A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const  *   input_prefix = "/path/to";
  char const     *input_suffix = "file.ext";
  ccptn_t const  *R, *P, *S;

  P = ccname_new(ccptn_t, pointer, clean)(L, A, P_H, input_prefix);
  S = ccname_new(ccptn_t, pointer, clean)(L, A, S_H, input_suffix);
  R = ccname_new(ccptn_t, concat)(L, A, R_H, R, P, S);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun {ccptn_t const *} {ccname_new(ccptn_t, concat, clean)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_clean_handler_t * @var{H}, ccptn_t const * @var{prefix}, ccptn_t const * @var{suffix})
@deftypefunx {ccptn_t const *} {ccname_new(ccptn_t, concat, error)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_error_handler_t * @var{H}, ccptn_t const * @var{prefix}, ccptn_t const * @var{suffix})
Like @cfunc{ccname_new(ccptn_t, concat)} but register the pathname instance to be destroyed using
the handler @var{H} in the context of the location @var{L}.

@example
cce_location_t           L[1];
ccptn_clean_handler_t    R_H[1], P_H[1], S_H[1];
ccmem_allocator_t const  *A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const  *   input_prefix = "/path/to";
  char const     *input_suffix = "file.ext";
  ccptn_t const  *R, *P, *S;

  P = ccname_new(ccptn_t, pointer, clean)(L, A, P_H, input_prefix);
  S = ccname_new(ccptn_t, pointer, clean)(L, A, S_H, input_suffix);
  R = ccname_new(ccptn_t, concat,  clean)(L, A, R_H, P, S);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun

@c page
@node components
@chapter Pathname components


@menu
* components extensions::       Extracting pathname extensions.
* components rootnames::        Extracting pathname rootnames.
* components dirnames::         Extracting pathname dirnames.
* components tailnames::        Extracting pathname tailnames.
* components filenames::        Extracting pathname filenames.
@end menu

@c page
@node components extensions
@section Extracting pathname extensions


An @dfn{extension} is the last portion of the last segment in an input pathname following the last
dot, but only if it is not the whole segment.  Examples:

@example
"/path/to/file.ext"     @result{} ".ext"
"/path/to/file"         @result{} ""
"/path/to/dir/"         @result{} ""
"/path/to/dir.ext/"     @result{} ".ext"
"file.ext"              @result{} ".ext"
".fvwmrc"               @result{} ""
"."                     @result{} ""
".."                    @result{} ""
"/"                     @result{} ""
@end example

Extension extraction is possible only for an input pathname that has been previously normalised; if
the input is not normalised: the functions below will raise an exception of type
@objtype{ccptn_condition_normalised_pathname_t}.


@deftp {Struct Typedef} ccptn_extension_t
Type of @struct{} representing the extension of a segment in a pathname; this @struct{} does
@strong{not} own the referenced memory.  Given the pathname:

@example
/path/to/file.ext
@end example

@noindent
the last segment is the string @samp{file.ext} and its extension is the string @samp{.ext},
@strong{including} the leading dot.

This type has the following fields:

@table @code
@item size_t len
The number of octets in the @code{ptr} array representing the extension in a pathname's segment.

@item char const * ptr
Pointer to the first octet in an @ascii{} string representing a pathname's segment's extension.  In
general this string is @strong{not} zero terminated.
@end table
@end deftp


@deftypefun ccptn_extension_t ccptn_extension (cce_destination_t @var{L}, ccptn_t const * @var{P})
Find the extension of the last segment in the input pathname referenced by @var{P} and return an
instance of @objtype{ccptn_extension_t} representing it; the returned value references the section
of data in the input pathname and so it is valid data only while the input pathname exists.  If an
error occurs: raise an exception by performing a non--local exit to @var{L}.

If the input pathname has no extension: the returned value represents the empty string by having the
length field to zero, while the pointer field references the terminating zero in the @asciiz{}
representation of the input pathname.
@end deftypefun


@deftypefun bool ccptn_extension_is_empty (ccptn_extension_t @var{E})
Return @ctrue{} if @var{E} is empty; otherwise return @cfalse{}.
@end deftypefun


@deftypefun bool ccptn_extension_equal (ccptn_extension_t @vari{E}, ccptn_extension_t @varii{E})
Return @ctrue{} if the extensions are equal octet by octet; otherwise return @cfalse{}.
@end deftypefun


@deftypefun void ccptn_extension_fwrite (cce_destination_t @var{L}, FILE * @var{stream}, ccptn_extension_t @var{E})
Print the extension to @var{stream}; do not flush the stream.  If an error occurs: raise an
exception by performing a non--local exit to @var{L}.
@end deftypefun

@c page
@node components rootnames
@section Extracting pathname rootnames


The @dfn{rootname} of an input pathname is a pathname representing the input with the extension of
the last segment stripped.  Examples:

@example
"/path/to/file.ext"     @result{} "/path/to/file"
"/path/to/file"         @result{} "/path/to/file"
"/path/to/dir/"         @result{} "/path/to/dir"
"file.ext"              @result{} "file.ext"
".fvwmrc"               @result{} ".fvwmrc"
"."                     @error{} no rootname
".."                    @error{} no rootname
"/"                     @error{} no rootname
@end example

It is an error to attempt rootname extraction from an input pathname that has no rootname; in this
case the functions below will raise an exception of type @objtype{ccptn_condition_no_rootname_t}.

Rootname extraction is possible only for an input pathname that has been previously rootnamed; if
the input is not rootnamed: the functions below will raise an exception of type
@objtype{ccptn_condition_rootnamed_pathname_t}.

@menu
* manipulations rootname embedded::    Obtaining a rootname embedded
                                       pathname.
* manipulations rootname standalone::  Obtaining a rootname standalone
                                       pathname.
@end menu

@c page
@node manipulations rootname embedded
@subsection Obtaining a rootname embedded pathname


An @dfn{embedded} instance of @objtype{ccptn_t} is allocated on the stack or embedded into an
enclosing data structure.  The constructors of such instances do not have to allocate memory for the
instance itself.


@deftypefun void {ccname_init(ccptn_t, rootname)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_t * @var{dst}, ccptn_t const * @var{src})
Initialise the already allocated @objtype{ccptn_t} instance, referenced by @var{dst}, representing
the result of extracting the rootname from the pathname represented by @var{src}; use the allocator
@var{A}.  When successful: just return.  If an error occurs: raise an exception by performing a
non--local exit to to @var{L}.

@example
cce_location_t           L[1];
ccptn_clean_handler_t    P_H[1], Q_H[1];
ccmem_allocator_t const  *A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const  *input = "/path/to/file.ext";
  ccptn_t     P[1], R[1];

  ccname_init(ccptn_t, pointer, clean)(L, A, P_H, P, input);
  ccname_init(ccptn_t, rootname)(L, A, R, P);
  ccptn_init_and_register_handler(L, R_H, R);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun void {ccname_init(ccptn_t, rootname, clean)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_clean_handler_t * @var{H}, ccptn_t * @var{dst}, ccptn_t const * @var{src})
@deftypefunx void {ccname_init(ccptn_t, rootname, error)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_error_handler_t * @var{H}, ccptn_t * @var{dst}, ccptn_t const * @var{src})
Like @cfunc{ccname_init(ccptn_t, rootname)} but register the pathname instance to be destroyed using
the handler @var{H} in the context of the location @var{L}.

@example
cce_location_t           L[1];
ccptn_clean_handler_t    P_H[1], Q_H[1];
ccmem_allocator_t const  *A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const  *input = "/path/to/file.ext";
  ccptn_t     P[1], R[1];

  ccname_init(ccptn_t, pointer,  clean)(L, A, P_H, P, input);
  ccname_init(ccptn_t, rootname, clean)(L, A, R_H, R, P);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun

@c page
@node manipulations rootname standalone
@subsection Obtaining a rootname standalone pathname


A @dfn{standalone} instance of @objtype{ccptn_t} is allocated on the heap.  The constructors of such
instances do have to allocate memory for the instance itself.


@deftypefun {ccptn_t const *} {ccname_new(ccptn_t, rootname)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_t const * @var{src})
Build a new @objtype{ccptn_t} instance representing the result of extracting the rootname from the
pathname represented by @var{src}; use the allocator @var{A}.  When successful: return a pointer to
the new instance.  If an error occurs: raise an exception by performing a non--local exit to to
@var{L}.

@example
cce_location_t             L[1];
ccptn_clean_handler_t      P_H[1], Q_H[1];
ccmem_allocator_t const *  A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const     *input = "/path/to/file.ext";
  ccptn_t const  *P, *Q;

  P = ccname_new(ccptn_t, pointer, clean)(L, A, P_H, input);
  Q = ccname_new(ccptn_t, rootname)(L, A, P);
  ccptn_init_and_register_handler(L, Q_H, Q);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun {ccptn_t const *} {ccname_new(ccptn_t, rootname, clean)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_clean_handler_t * @var{H}, ccptn_t const * @var{src})
@deftypefunx {ccptn_t const *} {ccname_new(ccptn_t, rootname, error)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_error_handler_t * @var{H}, ccptn_t const * @var{src})
Like @cfunc{ccname_new(ccptn_t, rootname)} but register the pathname instance to be destroyed using
the handler @var{H} in the context of the location @var{L}.

@example
cce_location_t           L[1];
ccptn_clean_handler_t    P_H[1], Q_H[1];
ccmem_allocator_t const  *A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const     *input = "/path/to/file.ext";
  ccptn_t const  *P, *R;

  P = ccname_init(ccptn_t, pointer,  clean)(L, A, P_H, input);
  Q = ccname_init(ccptn_t, rootname, clean)(L, A, R_H, P);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun

@c page
@node components dirnames
@section Extracting pathname dirnames


The @dfn{dirname} is the pathname representing the input pathname with the last segment stripped.
Examples:

@example
"/path/to/file.ext"     @result{} "/path/to"
"/path/to/dir/"         @result{} "/path/to"
"file.ext"              @error{} no dirname
"."                     @result{} ".."
".."                    @error{} no dirname
"/"                     @result{} "/"
@end example

It is an error to attempt dirname extraction from an input pathname that has no dirname; in this
case the functions below will raise an exception of type @objtype{ccptn_condition_no_dirname_t}.

Dirname extraction is possible only for an input pathname that has been previously normalised; if
the input is not normalised: the functions below will raise an exception of type
@objtype{ccptn_condition_normalised_pathname_t}.

@menu
* manipulations dirname embedded::    Obtaining a dirname embedded
                                      pathname.
* manipulations dirname standalone::  Obtaining a dirname standalone
                                      pathname.
@end menu

@c page
@node manipulations dirname embedded
@subsection Obtaining a dirname embedded pathname


An @dfn{embedded} instance of @objtype{ccptn_t} is allocated on the stack or embedded into an
enclosing data structure.  The constructors of such instances do not have to allocate memory for the
instance itself.


@deftypefun void {ccname_init(ccptn_t, dirname)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_t * @var{dst}, ccptn_t const * @var{src})
Initialise the already allocated @objtype{ccptn_t} instance, referenced by @var{dst}, representing
the result of extracting the dirname from the pathname represented by @var{src}; use the allocator
@var{A}.  When successful: just return.  If an error occurs: raise an exception by performing a
non--local exit to to @var{L}.

@example
cce_location_t           L[1];
ccptn_clean_handler_t    P_H[1], Q_H[1];
ccmem_allocator_t const  *A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const  *input = "/path/to/file.ext";
  ccptn_t     P[1], R[1];

  ccname_init(ccptn_t, pointer, clean)(L, A, P_H, P, input);
  ccname_init(ccptn_t, dirname)(L, A, R, P);
  ccptn_init_and_register_handler(L, R_H, R);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun void {ccname_init(ccptn_t, dirname, clean)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_clean_handler_t * @var{H}, ccptn_t * @var{dst}, ccptn_t const * @var{src})
@deftypefunx void {ccname_init(ccptn_t, dirname, error)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_error_handler_t * @var{H}, ccptn_t * @var{dst}, ccptn_t const * @var{src})
Like @cfunc{ccname_init(ccptn_t, dirname)} but register the pathname instance to be destroyed using
the handler @var{H} in the context of the location @var{L}.

@example
cce_location_t           L[1];
ccptn_clean_handler_t    P_H[1], Q_H[1];
ccmem_allocator_t const  *A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const  *input = "/path/to/file.ext";
  ccptn_t     P[1], R[1];

  ccname_init(ccptn_t, pointer, clean)(L, A, P_H, P, input);
  ccname_init(ccptn_t, dirname, clean)(L, A, R_H, R, P);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun

@c page
@node manipulations dirname standalone
@subsection Obtaining a dirname standalone pathname


A @dfn{standalone} instance of @objtype{ccptn_t} is allocated on the heap.  The constructors of such
instances do have to allocate memory for the instance itself.


@deftypefun {ccptn_t const *} {ccname_new(ccptn_t, dirname)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_t const * @var{src})
Build a new @objtype{ccptn_t} instance representing the result of extracting the dirname from the
pathname represented by @var{src}; use the allocator @var{A}.  When successful: return a pointer to
the new instance.  If an error occurs: raise an exception by performing a non--local exit to to
@var{L}.

@example
cce_location_t             L[1];
ccptn_clean_handler_t      P_H[1], Q_H[1];
ccmem_allocator_t const *  A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const     *input = "/path/to/file.ext";
  ccptn_t const  *P, *Q;

  P = ccname_new(ccptn_t, pointer, clean)(L, A, P_H, input);
  Q = ccname_new(ccptn_t, dirname)(L, A, P);
  ccptn_init_and_register_handler(L, Q_H, Q);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun {ccptn_t const *} {ccname_new(ccptn_t, dirname, clean)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_clean_handler_t * @var{H}, ccptn_t const * @var{src})
@deftypefunx {ccptn_t const *} {ccname_new(ccptn_t, dirname, error)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_error_handler_t * @var{H}, ccptn_t const * @var{src})
Like @cfunc{ccname_new(ccptn_t, dirname)} but register the pathname instance to be destroyed using
the handler @var{H} in the context of the location @var{L}.

@example
cce_location_t           L[1];
ccptn_clean_handler_t    P_H[1], Q_H[1];
ccmem_allocator_t const  *A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const     *input = "/path/to/file.ext";
  ccptn_t const  *P, *R;

  P = ccname_init(ccptn_t, pointer, clean)(L, A, P_H, input);
  Q = ccname_init(ccptn_t, dirname, clean)(L, A, R_H, P);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun

@c page
@node components tailnames
@section Extracting pathname tailnames


The @dfn{tailname} is the relative pathname representing the last segment of an input pathname.
Examples:

@example
"/path/to/file.ext"     @result{} "file.ext"
"/path/to/dir/"         @result{} "dir/"
"file.ext"              @result{} "file.ext"
"."                     @result{} "."
".."                    @result{} ".."
"/"                     @error{} no tailname
@end example

Every pathname has a tailname with the exception of @file{/}.

It is an error to attempt tailname extraction from an input pathname that has no tailname; in this
case the functions below will raise an exception of type @objtype{ccptn_condition_no_tailname_t}.

Tailname extraction is possible only for an input pathname that has been previously normalised; if
the input is not normalised: the functions below will raise an exception of type
@objtype{ccptn_condition_normalised_pathname_t}.

@menu
* manipulations tailname embedded::    Obtaining a tailname embedded
                                       pathname.
* manipulations tailname standalone::  Obtaining a tailname standalone
                                       pathname.
@end menu

@c page
@node manipulations tailname embedded
@subsection Obtaining a tailname embedded pathname


An @dfn{embedded} instance of @objtype{ccptn_t} is allocated on the stack or embedded into an
enclosing data structure.  The constructors of such instances do not have to allocate memory for the
instance itself.


@deftypefun void {ccname_init(ccptn_t, tailname)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_t * @var{dst}, ccptn_t const * @var{src})
Initialise the already allocated @objtype{ccptn_t} instance, referenced by @var{dst}, representing
the result of extracting the tailname from the pathname represented by @var{src}; use the allocator
@var{A}.  When successful: just return.  If an error occurs: raise an exception by performing a
non--local exit to to @var{L}.

@example
cce_location_t           L[1];
ccptn_clean_handler_t    P_H[1], Q_H[1];
ccmem_allocator_t const  *A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const  *input = "/path/to/file.ext";
  ccptn_t     P[1], R[1];

  ccname_init(ccptn_t, pointer, clean)(L, A, P_H, P, input);
  ccname_init(ccptn_t, tailname)(L, A, R, P);
  ccptn_init_and_register_handler(L, R_H, R);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun void {ccname_init(ccptn_t, tailname, clean)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_clean_handler_t * @var{H}, ccptn_t * @var{dst}, ccptn_t const * @var{src})
@deftypefunx void {ccname_init(ccptn_t, tailname, error)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_error_handler_t * @var{H}, ccptn_t * @var{dst}, ccptn_t const * @var{src})
Like @cfunc{ccname_init(ccptn_t, tailname)} but register the pathname instance to be destroyed using
the handler @var{H} in the context of the location @var{L}.

@example
cce_location_t           L[1];
ccptn_clean_handler_t    P_H[1], Q_H[1];
ccmem_allocator_t const  *A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const  *input = "/path/to/file.ext";
  ccptn_t     P[1], R[1];

  ccname_init(ccptn_t, pointer,  clean)(L, A, P_H, P, input);
  ccname_init(ccptn_t, tailname, clean)(L, A, R_H, R, P);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun

@c page
@node manipulations tailname standalone
@subsection Obtaining a tailname standalone pathname


A @dfn{standalone} instance of @objtype{ccptn_t} is allocated on the heap.  The constructors of such
instances do have to allocate memory for the instance itself.


@deftypefun {ccptn_t const *} {ccname_new(ccptn_t, tailname)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_t const * @var{src})
Build a new @objtype{ccptn_t} instance representing the result of extracting the tailname from the
pathname represented by @var{src}; use the allocator @var{A}.  When successful: return a pointer to
the new instance.  If an error occurs: raise an exception by performing a non--local exit to to
@var{L}.

@example
cce_location_t             L[1];
ccptn_clean_handler_t      P_H[1], Q_H[1];
ccmem_allocator_t const *  A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const     *input = "/path/to/file.ext";
  ccptn_t const  *P, *Q;

  P = ccname_new(ccptn_t, pointer, clean)(L, A, P_H, input);
  Q = ccname_new(ccptn_t, tailname)(L, A, P);
  ccptn_init_and_register_handler(L, Q_H, Q);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun {ccptn_t const *} {ccname_new(ccptn_t, tailname, clean)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_clean_handler_t * @var{H}, ccptn_t const * @var{src})
@deftypefunx {ccptn_t const *} {ccname_new(ccptn_t, tailname, error)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_error_handler_t * @var{H}, ccptn_t const * @var{src})
Like @cfunc{ccname_new(ccptn_t, tailname)} but register the pathname instance to be destroyed using
the handler @var{H} in the context of the location @var{L}.

@example
cce_location_t           L[1];
ccptn_clean_handler_t    P_H[1], Q_H[1];
ccmem_allocator_t const  *A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const     *input = "/path/to/file.ext";
  ccptn_t const  *P, *R;

  P = ccname_init(ccptn_t, pointer,  clean)(L, A, P_H, input);
  Q = ccname_init(ccptn_t, tailname, clean)(L, A, R_H, P);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun

@c page
@node components filenames
@section Extracting pathname filenames


The @dfn{filename} is the relative pathname representing the last segment of an input pathname, if
it does not represent a directory.  Examples:

@example
"/path/to/file.ext"     @result{} "file.ext"
"/path/to/dir/"         @error{} no filename
"file.ext"              @result{} "file.ext"
"."                     @error{} no filename
".."                    @error{} no filename
"/"                     @error{} no filename
@end example

It is an error to attempt filename extraction from an input pathname that has no filename; in this
case the functions below will raise an exception of type @objtype{ccptn_condition_no_filename_t}.

Filename extraction is possible only for an input pathname that has been previously normalised; if
the input is not normalised: the functions below will raise an exception of type
@objtype{ccptn_condition_normalised_pathname_t}.

@menu
* manipulations filename embedded::    Obtaining a filename embedded
                                       pathname.
* manipulations filename standalone::  Obtaining a filename standalone
                                       pathname.
@end menu

@c page
@node manipulations filename embedded
@subsection Obtaining a filename embedded pathname


An @dfn{embedded} instance of @objtype{ccptn_t} is allocated on the stack or embedded into an
enclosing data structure.  The constructors of such instances do not have to allocate memory for the
instance itself.


@deftypefun void {ccname_init(ccptn_t, filename)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_t * @var{dst}, ccptn_t const * @var{src})
Initialise the already allocated @objtype{ccptn_t} instance, referenced by @var{dst}, representing
the result of extracting the filename from the pathname represented by @var{src}; use the allocator
@var{A}.  When successful: just return.  If an error occurs: raise an exception by performing a
non--local exit to to @var{L}.

@example
cce_location_t           L[1];
ccptn_clean_handler_t    P_H[1], Q_H[1];
ccmem_allocator_t const  *A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const  *input = "/path/to/file.ext";
  ccptn_t     P[1], R[1];

  ccname_init(ccptn_t, pointer, clean)(L, A, P_H, P, input);
  ccname_init(ccptn_t, filename)(L, A, R, P);
  ccptn_init_and_register_handler(L, R_H, R);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun void {ccname_init(ccptn_t, filename, clean)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_clean_handler_t * @var{H}, ccptn_t * @var{dst}, ccptn_t const * @var{src})
@deftypefunx void {ccname_init(ccptn_t, filename, error)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_error_handler_t * @var{H}, ccptn_t * @var{dst}, ccptn_t const * @var{src})
Like @cfunc{ccname_init(ccptn_t, filename)} but register the pathname instance to be destroyed using
the handler @var{H} in the context of the location @var{L}.

@example
cce_location_t           L[1];
ccptn_clean_handler_t    P_H[1], Q_H[1];
ccmem_allocator_t const  *A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const  *input = "/path/to/file.ext";
  ccptn_t     P[1], R[1];

  ccname_init(ccptn_t, pointer,  clean)(L, A, P_H, P, input);
  ccname_init(ccptn_t, filename, clean)(L, A, R_H, R, P);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun

@c page
@node manipulations filename standalone
@subsection Obtaining a filename standalone pathname


A @dfn{standalone} instance of @objtype{ccptn_t} is allocated on the heap.  The constructors of such
instances do have to allocate memory for the instance itself.


@deftypefun {ccptn_t const *} {ccname_new(ccptn_t, filename)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_t const * @var{src})
Build a new @objtype{ccptn_t} instance representing the result of extracting the filename from the
pathname represented by @var{src}; use the allocator @var{A}.  When successful: return a pointer to
the new instance.  If an error occurs: raise an exception by performing a non--local exit to to
@var{L}.

@example
cce_location_t             L[1];
ccptn_clean_handler_t      P_H[1], Q_H[1];
ccmem_allocator_t const *  A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const     *input = "/path/to/file.ext";
  ccptn_t const  *P, *Q;

  P = ccname_new(ccptn_t, pointer, clean)(L, A, P_H, input);
  Q = ccname_new(ccptn_t, filename)(L, A, P);
  ccptn_init_and_register_handler(L, Q_H, Q);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun {ccptn_t const *} {ccname_new(ccptn_t, filename, clean)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_clean_handler_t * @var{H}, ccptn_t const * @var{src})
@deftypefunx {ccptn_t const *} {ccname_new(ccptn_t, filename, error)} (cce_destination_t @var{L}, ccmem_allocator_t const * @var{A}, ccptn_error_handler_t * @var{H}, ccptn_t const * @var{src})
Like @cfunc{ccname_new(ccptn_t, filename)} but register the pathname instance to be destroyed using
the handler @var{H} in the context of the location @var{L}.

@example
cce_location_t           L[1];
ccptn_clean_handler_t    P_H[1], Q_H[1];
ccmem_allocator_t const  *A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const     *input = "/path/to/file.ext";
  ccptn_t const  *P, *R;

  P = ccname_init(ccptn_t, pointer,  clean)(L, A, P_H, input);
  Q = ccname_init(ccptn_t, filename, clean)(L, A, R_H, P);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun

@c page
@node io
@chapter Pathname input/output


@deftypefun void ccptn_fwrite (cce_destination_t @var{L}, FILE * @var{stream}, ccptn_t const * @var{P})
Print the pathname to @var{stream}; do not flush the stream.  If an error occurs: raise an exception
by performing a non--local exit to @var{L}.
@end deftypefun

@c page
@node traits
@chapter Implemented traits


The type @objtype{ccptn_t}  implements some traits defined by the package CCStructs;
@ccstructsref{Top, CCStructs}.


@menu
* traits pathname::             The @trait{pathname} trait.
* traits dtor::                 The @trait{dtor} trait.
* traits dumpable::             The @trait{dumpable} trait.
* traits serialiser::           The @trait{serialiser} trait.
* traits deserialiser::         The @trait{deserialiser} trait.
@end menu

@c page
@node traits pathname
@section The @trait{pathname} trait


The @trait{pathname} trait offers a common @api{} for the manipulation of @struct{} types
implementing file system pathname representations; @ccstructsref{pathname, The @trait{pathname}
trait}.


@deftypefun ccstructs_pathname_T {ccname_trait_new(ccstructs_pathname_T, ccptn_t)} (ccptn_t const * @var{P})
Build and return an instance of @trait{pathname} trait operating on instances of @objtype{ccptn_t}
referenced by @var{P}.
@end deftypefun


Code sample:

@smallexample
cce_location_t                L[1];
ccstructs_clean_handler_t     H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  static char const     *input = "/path/to/file.ext";
  ccptn_t const         *P;
  ccstructs_pathname_T  TPTN;
  ccstructs_dtor_T      TDTOR;

  P     = ccname_new(ccptn_t, pointer)(L, A, input);
  TPTN  = ccname_trait_new(ccstructs_pathname_T, ccptn_t)(P);
  TDTOR = ccname_trait_new(ccstructs_dtor_T, ccstructs_pathname_T)(TPTN);
  ccstructs_init_and_register_handler(L, H, TDTOR);

  @{
    ccstructs_dumpable_T  IDUMP =
      ccname_trait_new(ccstructs_dumpable_T, ccstructs_pathname_T)(L, TPTN);

    ccstructs_dumpable_dump(L, IDUMP);
    fprintf(stderr, "\n");
  @}
  cce_run_body_handlers(L);
@}
@end smallexample

@c page
@node traits dtor
@section The @trait{dtor} trait


The @trait{dtor} trait offers a common @api{} for the destruction of @struct{} types;
@ccstructsref{dtor, The @trait{dtor} trait}.


@deftypefun ccstructs_dtor_T {ccname_trait_new(ccstructs_dtor_T, ccptn_t)} (ccptn_t const * @var{P})
Build and return an instance of @trait{dtor} trait which we can use to destroy both embedded and
standalone instances of @objtype{ccptn_t} referenced by @var{P}.  It is usually better to use the
handlers @api{} or, even better, the guarded constructors.
@end deftypefun


We can use the @trait{dtor} trait with the generic handlers @api{} defined by CCStructs,
@ccstructsref{dtor handlers, Exception handlers}.  Code sample:

@example
cce_location_t             L[1];
ccstructs_clean_handler_t  H[1];
ccmem_allocator_t const *  A = ccmem_standard_allocator;

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const        *input = "/path/to/file.ext";
  ccptn_t           P[1];
  ccstructs_dtor_T  ID;

  ccname_init(ccptn_t, pointer)(L, A, input);
  ID = ccname_trait_new(ccstructs_dtor_T, ccptn_t)(P);
  ccstructs_init_and_register_handler(L, H, ID);

  cce_run_body_handlers(L);
@}
@end example

@c page
@node traits dumpable
@section The @trait{dumpable} trait


The @trait{dumpable} trait offers a common @api{} for to print a @struct{} representation for
debugging purposes; @ccstructsref{dumpable, The @trait{dumpable} trait}.


@deftypefun ccstructs_dumpable_T {ccname_trait_new(ccstructs_dumpable_T, ccptn_t)} (ccptn_t const * @var{P})
Build and return an instance of @trait{dumpable} trait which we can use to print on @stderr{} a
representation of @objtype{ccptn_t} referenced by @var{P}.  This trait does not print an ending
newline.
@end deftypefun


Code sample:

@example
cce_location_t        L[1];
ccptn_clean_handler_t H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const            *input = "/path/to/file.ext";
  ccptn_t const         *P;
  ccstructs_dumpable_T  ID;

  P  = ccname_new(ccptn_t, pointer, clean)(L, A, H, input);
  ID = ccname_trait_new(ccstructs_dumpable_T, ccptn_t)(P);

  ccstructs_dumpable_dump(L, ID);
  fprintf(stderr, "\n");

  cce_run_body_handlers(L);
@}
@end example

@c page
@node traits serialiser
@section The @trait{serialiser} trait


The @trait{serialiser} trait offers a common @api{} to serialise a @struct{} to a memory block
for storage purposes; @ccstructsref{serialiser, The @trait{serialiser} trait}.


@deftypefun ccstructs_serialiser_T {ccname_trait_new(ccstructs_serialiser_T, ccptn_t)} (ccptn_t const * @var{P})
Build and return an instance of @trait{serialiser} trait which we can use to serialise the instance
of @objtype{ccptn_t} referenced by @var{P}.
@end deftypefun

@c page
@node traits deserialiser
@section The @trait{deserialiser} trait


The @trait{deserialiser} trait offers a common @api{} to deserialise a @struct{} from a memory
block for storage retrieval purposes; @ccstructsref{deserialiser, The @trait{deserialiser}
trait}.


@deftypefun ccstructs_deserialiser_T {ccname_trait_new(ccstructs_deserialiser_T, ccptn_t)} (ccptn_t * @var{P})
Build and return an instance of @trait{deserialiser} trait which we can use to deserialise an
instance of @objtype{ccptn_t} into the @struct{} referenced by @var{P}.
@end deftypefun

@c page
@node segments
@chapter Manipulating segments


@deftp {Struct Typedef} ccptn_segment_t
This @code{struct} represents a segment in a pathname; this struct does not own the referenced
memory.  Given the pathname:

@example
/path/to/file.ext
@end example

@noindent
the segments are the strings:

@example
path
to
file.ext
@end example

@noindent
notice that the slash separators are @strong{excluded}.  This type has the following fields:

@table @code
@item size_t len
The number of octets in the @code{ptr} array representing a segment of pathname.

@item char const * ptr
Pointer to the first octet in an @ascii{} string representing a pathname's segment.  In general, it
is @strong{not} an @asciiz{} string: it is not zero terminated.
@end table
@end deftp


@deftypefun bool ccptn_segment_is_empty (ccptn_segment_t @var{S})
Return @ctrue{} if @var{S} is empty; otherwise return @cfalse{}.
@end deftypefun


@deftypefun bool ccptn_segment_is_dot (ccptn_segment_t @var{S})
Return @ctrue{} if @var{S} represents a single dot: @samp{.}; otherwise return @cfalse{}.
@end deftypefun


@deftypefun bool ccptn_segment_is_double_dot (ccptn_segment_t @var{S})
Return @ctrue{} if @var{S} represents a double dot: @samp{..}; otherwise return @cfalse{}.
@end deftypefun


@deftypefun ccptn_segment_t ccptn_segment_next (char const * @var{ptr}, size_t @var{len})
Given a pointer @var{ptr} to an @ascii{} string of at least @var{len} octets: return a segment
@code{struct} referencing the octects up to, but not including, the first slash character or the end
of the string.  The returned segment does @strong{not} include a terminating zero octet.
@end deftypefun


@deftypefun size_t ccptn_segment_size_of_next (char const * @var{in}, size_t @var{len})
Given a pointer @var{in} to an @ascii{} string of at least @var{len} octets: return the number of
octets between the one referenced by @var{in} (included) and the first slash octet (excluded);
return @var{len} itself if no slash is found.
@end deftypefun


@deftypefun void ccptn_segment_print (cce_destination_t @var{L}, FILE * @var{stream}, ccptn_segment_t @var{S})
Print the segment to @var{stream}; do not flush the stream.  If an error occurs: raise an exception
by performing a non--local exit to @var{L}.
@end deftypefun

@c page
@node utils
@chapter Utility definitions


@defmac CCPTN_PC (@var{POINTER_TYPE}, @var{POINTER_NAME}, @var{EXPRESSION})
Preprocessor macro used to define pointer variables initialised with a cast expression.  It expands
to:

@example
POINTER_TYPE * POINTER_NAME = (POINTER_TYPE *) (EXPRESSION)
@end example

For example, the macro use:

@example
CCPTN_PC(ccpathnames_descriptor_test_failure_t, C, _C);
@end example

@noindent
expands into:

@example
ccpathnames_descriptor_test_failure_t * C = \
   (ccpathnames_descriptor_test_failure_t *) (_C);
@end example
@end defmac


@defmac CCPTN_UNUSED
Preprocessor macro that is meant to expand into an attribute declaration.  If the symbol
@code{__GNUC__} is defined, the expansion is:

@example
__attribute__((__unused__))
@end example

@noindent
otherwise the expansion is the empty string.
@end defmac

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include lgpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DocumentationUrl}

@noindent
the latest release of this package can be downloaded from:

@center @value{DownloadUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
and as backup at:

@center @value{BitbucketUrl}

@noindent
the package CCExceptions is available at:

@center @url{https://github.com/marcomaggi/ccexceptions/}

@noindent
the package CCMemory is available at:

@center @url{https://github.com/marcomaggi/ccmemory/}

@noindent
the package CCStructs is available at:

@center @url{https://github.com/marcomaggi/ccstructs/}

@noindent
the package CCTests is available at:

@center @url{https://github.com/marcomaggi/cctests/}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file
@c Local Variables:
@c TeX-master: t
@c End:
