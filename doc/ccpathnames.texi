\input texinfo.tex
@c %**start of header
@setfilename ccpathnames.info
@settitle CCPathnames
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      CCPathnames

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    CCPathnames

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           ccpathnames

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@poste.it}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2018

@c ------------------------------------------------------------

@set CCEXCEPTIONS_VERSION       0.8.0
@set CCMEMORY_VERSION           0.1.0
@set CCTESTS_VERSION            0.3.0

@set GITHUB_URL                 @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set BITBUCKET_URL              @url{https://bitbucket.org/mmstuff/@value{PACKAGE_NICKNAME}}
@set DOWNLOAD_URL               @url{https://bitbucket.org/mmstuff/@value{PACKAGE_NICKNAME}/downloads}
@set DOCUMENTATION_URL          @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library
implementing Unix pathnames manipulation functions.

This package supports @posix{} platforms.  This package depends on the packages: CCExceptions, at
least version @value{CCEXCEPTIONS_VERSION}; CCMemory, at least version @value{CCMEMORY_VERSION}.  To
run the test suite: this package depends upon the package CCTests, at least version
@value{CCTESTS_VERSION}.

This package is distributed under the terms of the @gnu{} Lesser General Public License (@lgpl{}).

The latest release can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} General
Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* ccpathnames: (ccpathnames).   CCPathnames a Unix pathnames
                                manipulation library.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* init::                        Library initialisation.
* conditions::                  Exceptional condition objects.
* memory::                      Custom memory allocation.
* typedefs::                    Type definitions.
* ctors::                       Constructing pathname representations.
* dtors::                       Destructing pathname representations.
* guarded::                     Guarded constructors.
* predicates::                  Pathname predicates.
* accessors::                   Pathname accessors.
* manipulations::               Pathname manipulations.
* components::                  Pathname components.
* io::                          Pathname input/output.
* segments::                    Manipulating segments.
* extensions::                  Manipulating extensions.
* utils::                       Utility definitions.

Appendices

* Package License::             GNU Lesser General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a C11 language library
implementing Unix pathnames manipulation functions.

This package supports @posix{} platforms.  This package depends on the packages: CCExceptions, at
least version @value{CCEXCEPTIONS_VERSION}; CCMemory, at least version @value{CCMEMORY_VERSION}.  To
run the test suite: this package depends upon the package CCTests, at least version
@value{CCTESTS_VERSION}.

@value{PACKAGE} installs the single header file @file{ccpathnames.h}.  All the function names in the
@api{} are prefixed with @code{ccptn_}; all the preprocessor symbol names are prefixed with
@code{CCPTN_}; all the type names are prefixed with @code{ccptn_} and suffixed with @code{_t}.

Notice that, before using the library, we need to call the global initialisation function
@cfunc{ccptn_library_init}.

@menu
* overview linking::            Linking code with the library.
@end menu

@c page
@node overview linking
@section Linking code with the library


This package installs a data file for @command{pkg-config}, so when searching for the installed
library with the @gnu{} Autotools, we can add the following macro use to @file{configure.ac}:

@example
PKG_CHECK_MODULES([CCPATHNAMES],[ccpathnames >= 0.2])
@end example

@noindent
which will set the variables @code{CCPATHNAMES_LIBS} and @code{CCPATHNAMES_CFLAGS}.  To avoid
problems with @command{pkg-config}, we need to remember that:

@itemize
@item
The macro file defining @code{PKG_CHECK_MODULES} is installed by the package @code{pkg-config}; such
file usually is in one of the locations:

@center @file{/usr/share/aclocal/pkg.m4}
@center @file{/usr/local/share/aclocal/pkg.m4}

@item
The macro file is located by @command{aclocal}, which in turn is installed by the package @gnu{}
Automake; @command{aclocal} is used by @command{autoreconf}.  We must make sure that
@command{aclocal} finds the installed macro files; for this purpose we can use the environment
variable @env{ACLOCAL_PATH}; under a Bourne shell we can do this with:

@example
export ACLOCAL_PATH=/usr/local/share/aclocal:/usr/share/aclocal
@end example
@end itemize

Alternatively we can use the raw @gnu{} Autoconf macros:

@example
AC_CHECK_LIB([ccpathnames],[ccptn_version_string],,
  [AC_MSG_FAILURE([test for CCPathnames library failed])])
AC_CHECK_HEADERS([ccpathnames.h],,
  [AC_MSG_FAILURE([test for CCPathnames header failed])])
@end example

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@deftypefun {char const *} ccptn_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing the interface version
number.
@end deftypefun


@deftypefun int ccptn_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int ccptn_version_interface_revision (void)
Return an integer representing the library interface current revision number.
@end deftypefun


@deftypefun int ccptn_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node init
@chapter Library initialisation


@deftypefun void ccptn_library_init (void)
Initialise the internal structures of the library.  It is fine to call this function multiple times.

@quotation
@strong{NOTE} This function is defined with the @gcc{} attribute @code{constructor}, so, when the
library is built with @gcc{}: it will be called automatically by the library initialisation code.
@end quotation
@end deftypefun

@c page
@node conditions
@chapter Exceptional condition objects


@menu
* conditions invalid::          Invalid pathname condition object.
* conditions length::           Maximum pathname length exceeded.
* conditions zero length::      Zero-length pathname.
* conditions invalid length::   Invalid length pathname.
* conditions normalised::       Normalised pathname required.
* conditions no dirname::       Directory part is missing.
* conditions no filename::      Filename is missing.
* conditions no tailname::      Tailname is missing.
* conditions no rootname::      Rootname is missing.
@end menu

@c page
@node conditions invalid
@section Invalid pathname condition object


The @dfn{invalid pathname exceptional--condition object} has the purpose of describing an
exceptional condition caused by attempting to use an invalid pathname.

There should be only one @emph{invalid pathname} condition object: the one predefined by
@value{PACKAGE}.

All the following definitions are accessible from the header file @file{ccpathnames.h}.


@deftp {Struct Typedef} ccptn_descriptor_invalid_pathname_t
Structure type representing the descriptor for @emph{invalid pathname} condition objects.  This
descriptor has @objtype{cce_descriptor_runtime_error_t} as parent descriptor.
@end deftp


@deftp {Struct Typedef} ccptn_condition_invalid_pathname_t
Structure type representing an @emph{invalid pathname} condition object.
@end deftp


@deftypefun void ccptn_condition_init_invalid_pathname (ccptn_condition_invalid_pathname_t * @var{C})
Initialise an already allocated condition object.  This function exists to allow sub--typing from
@objtype{ccptn_condition_invalid_pathname_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} ccptn_condition_new_invalid_pathname (void)
Return a pointer to the statically allocated structure representing the single @emph{invalid
pathname} condition object.
@end deftypefun


@deftypefun bool ccptn_condition_is_invalid_pathname (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} is an @emph{invalid pathname} condition object; otherwise return
@cfalse{}.
@end deftypefun

@c page
@node conditions length
@section Maximum pathname length exceeded


The @dfn{exceeded length exceptional--condition object} has the purpose of describing an exceptional
condition caused by attempting an operation that would generate a too long pathname.

There should be only one @emph{exceeded length} condition object: the one predefined by
@value{PACKAGE}.

All the following definitions are accessible from the header file @file{ccpathnames.h}.


@deftp {Struct Typedef} ccptn_descriptor_exceeded_length_t
Structure type representing the descriptor for @emph{exceeded length} condition objects.  This
descriptor has @objtype{cce_descriptor_runtime_error_t} as parent descriptor.
@end deftp


@deftp {Struct Typedef} ccptn_condition_exceeded_length_t
Structure type representing an @emph{exceeded length} condition object.
@end deftp


@deftypefun void ccptn_condition_init_exceeded_length (ccptn_condition_exceeded_length_t * @var{C})
Initialise an already allocated condition object.  This function exists to allow sub--typing from
@objtype{ccptn_condition_exceeded_length_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} ccptn_condition_new_exceeded_length (void)
Return a pointer to the statically allocated structure representing the single @emph{exceeded
length} condition object.
@end deftypefun


@deftypefun bool ccptn_condition_is_exceeded_length (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} is an @emph{exceeded length} condition object; otherwise return
@cfalse{}.
@end deftypefun

@c page
@node conditions zero length
@section Zero--length pathname


The @dfn{zero--length exceptional--condition object} has the purpose of describing an exceptional
condition caused by attempting an operation that would generate zero--length pathname.

There should be only one @emph{zero length} condition object: the one predefined by @value{PACKAGE}.

All the following definitions are accessible from the header file @file{ccpathnames.h}.


@deftp {Struct Typedef} ccptn_descriptor_zero_length_t
Structure type representing the descriptor for @emph{zero length} condition objects.  This
descriptor has @objtype{cce_descriptor_runtime_error_t} as parent descriptor.
@end deftp


@deftp {Struct Typedef} ccptn_condition_zero_length_t
Structure type representing an @emph{zero length} condition object.
@end deftp


@deftypefun void ccptn_condition_init_zero_length (ccptn_condition_zero_length_t * @var{C})
Initialise an already allocated condition object.  This function exists to allow sub--typing from
@objtype{ccptn_condition_zero_length_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} ccptn_condition_new_zero_length (void)
Return a pointer to the statically allocated structure representing the single @emph{zero length}
condition object.
@end deftypefun


@deftypefun bool ccptn_condition_is_zero_length (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} is an @emph{zero length} condition object; otherwise return @cfalse{}.
@end deftypefun

@c page
@node conditions invalid length
@section Invalid length pathname


The @dfn{invalid length exceptional--condition object} has the purpose of describing an exceptional
condition caused by attempting an operation on a pathname string that contains a non--terminating
zero octet.

There should be only one @emph{invalid length} condition object: the one predefined by
@value{PACKAGE}.

All the following definitions are accessible from the header file @file{ccpathnames.h}.


@deftp {Struct Typedef} ccptn_descriptor_invalid_length_t
Structure type representing the descriptor for @emph{invalid length} condition objects.  This
descriptor has @objtype{cce_descriptor_runtime_error_t} as parent descriptor.
@end deftp


@deftp {Struct Typedef} ccptn_condition_invalid_length_t
Structure type representing an @emph{invalid length} condition object.
@end deftp


@deftypefun void ccptn_condition_init_invalid_length (ccptn_condition_invalid_length_t * @var{C})
Initialise an already allocated condition object.  This function exists to allow sub--typing from
@objtype{ccptn_condition_invalid_length_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} ccptn_condition_new_invalid_length (void)
Return a pointer to the statically allocated structure representing the single @emph{invalid length}
condition object.
@end deftypefun


@deftypefun bool ccptn_condition_is_invalid_length (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} is an @emph{invalid length} condition object; otherwise return @cfalse{}.
@end deftypefun

@c page
@node conditions normalised
@section Normalised pathname required


The @dfn{normalised pathname exceptional--condition object} has the purpose of describing an
exceptional condition caused by attempting an operation on a pathname that is @strong{not}
normalised, while the operation requires that it is.

There should be only one @emph{normalised pathname} condition object: the one predefined by
@value{PACKAGE}.

All the following definitions are accessible from the header file @file{ccpathnames.h}.


@deftp {Struct Typedef} ccptn_descriptor_normalised_pathname_t
Structure type representing the descriptor for @emph{normalised pathname} condition objects.  This
descriptor has @objtype{ccptn_descriptor_invalid_pathname_t} as parent descriptor.
@end deftp


@deftp {Struct Typedef} ccptn_condition_normalised_pathname_t
Structure type representing an @emph{normalised pathname} condition object.
@end deftp


@deftypefun void ccptn_condition_init_normalised_pathname (ccptn_condition_normalised_pathname_t * @var{C})
Initialise an already allocated condition object.  This function exists to allow sub--typing from
@objtype{ccptn_condition_normalised_pathname_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} ccptn_condition_new_normalised_pathname (void)
Return a pointer to the statically allocated structure representing the single @emph{normalised
pathname} condition object.
@end deftypefun


@deftypefun bool ccptn_condition_is_normalised_pathname (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} is an @emph{normalised pathname} condition object; otherwise return
@cfalse{}.
@end deftypefun

@c page
@node conditions no dirname
@section Directory part is missing


The @dfn{no dirname exceptional--condition object} has the purpose of describing an exceptional
condition caused by attempting an operation on a pathname that has no directory part, when this is
required.  The dirname is the pathname representing the input pathname with the last segment
stripped.  Examples:

@example
"/path/to/file.ext"     @result{} "/path/to"
"/path/to/dir/"         @result{} "/path/to"
"file.ext"              @error{} no dirname
"."                     @result{} ".."
".."                    @error{} no dirname
@end example

There should be only one @emph{no dirname} condition object: the one predefined by @value{PACKAGE}.

All the following definitions are accessible from the header file @file{ccpathnames.h}.


@deftp {Struct Typedef} ccptn_descriptor_no_dirname_t
Structure type representing the descriptor for @emph{no dirname} condition objects.  This descriptor
has @objtype{ccptn_descriptor_invalid_pathname_t} as parent descriptor.
@end deftp


@deftp {Struct Typedef} ccptn_condition_no_dirname_t
Structure type representing an @emph{no dirname} condition object.
@end deftp


@deftypefun void ccptn_condition_init_no_dirname (ccptn_condition_no_dirname_t * @var{C})
Initialise an already allocated condition object.  This function exists to allow sub--typing from
@objtype{ccptn_condition_no_dirname_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} ccptn_condition_new_no_dirname (void)
Return a pointer to the statically allocated structure representing the single @emph{no dirname}
condition object.
@end deftypefun


@deftypefun bool ccptn_condition_is_no_dirname (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} is an @emph{no dirname} condition object; otherwise return @cfalse{}.
@end deftypefun

@c page
@node conditions no filename
@section Filename is missing


The @dfn{no filename exceptional--condition object} has the purpose of describing an exceptional
condition caused by attempting an operation on a pathname that has no filename part, when this is
required.  The filename is the relative pathname representing the last segment if it does not
represent a directory.  Examples:

@example
"/path/to/file.ext"     @result{} "file.ext"
"/path/to/dir/"         @error{} no filename
"file.ext"              @result{} "file.ext"
"."                     @error{} no filename
".."                    @error{} no filename
@end example

There should be only one @emph{no filename} condition object: the one predefined by @value{PACKAGE}.

All the following definitions are accessible from the header file @file{ccpathnames.h}.


@deftp {Struct Typedef} ccptn_descriptor_no_filename_t
Structure type representing the descriptor for @emph{no filename} condition objects.  This
descriptor has @objtype{ccptn_descriptor_invalid_pathname_t} as parent descriptor.
@end deftp


@deftp {Struct Typedef} ccptn_condition_no_filename_t
Structure type representing an @emph{no filename} condition object.
@end deftp


@deftypefun void ccptn_condition_init_no_filename (ccptn_condition_no_filename_t * @var{C})
Initialise an already allocated condition object.  This function exists to allow sub--typing from
@objtype{ccptn_condition_no_filename_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} ccptn_condition_new_no_filename (void)
Return a pointer to the statically allocated structure representing the single @emph{no filename}
condition object.
@end deftypefun


@deftypefun bool ccptn_condition_is_no_filename (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} is an @emph{no filename} condition object; otherwise return @cfalse{}.
@end deftypefun

@c page
@node conditions no tailname
@section Tailname is missing


The @dfn{no tailname exceptional--condition object} has the purpose of describing an exceptional
condition caused by attempting an operation on a pathname that has no tailname part, when this is
required.  The tailname is the relative pathname representing the last segment.  Examples:

@example
"/path/to/file.ext"     @result{} "file.ext"
"/path/to/dir/"         @result{} "dir/"
"file.ext"              @result{} "file.ext"
"."                     @result{} "."
".."                    @result{} ".."
"/"                     @error{} no tailname
@end example

There should be only one @emph{no tailname} condition object: the one predefined by @value{PACKAGE}.

All the following definitions are accessible from the header file @file{ccpathnames.h}.


@deftp {Struct Typedef} ccptn_descriptor_no_tailname_t
Structure type representing the descriptor for @emph{no tailname} condition objects.  This
descriptor has @objtype{ccptn_descriptor_invalid_pathname_t} as parent descriptor.
@end deftp


@deftp {Struct Typedef} ccptn_condition_no_tailname_t
Structure type representing an @emph{no tailname} condition object.
@end deftp


@deftypefun void ccptn_condition_init_no_tailname (ccptn_condition_no_tailname_t * @var{C})
Initialise an already allocated condition object.  This function exists to allow sub--typing from
@objtype{ccptn_condition_no_tailname_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} ccptn_condition_new_no_tailname (void)
Return a pointer to the statically allocated structure representing the single @emph{no tailname}
condition object.
@end deftypefun


@deftypefun bool ccptn_condition_is_no_tailname (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} is an @emph{no tailname} condition object; otherwise return @cfalse{}.
@end deftypefun

@c page
@node conditions no rootname
@section Rootname is missing


The @dfn{no rootname exceptional--condition object} has the purpose of describing an exceptional
condition caused by attempting an operation on a pathname that has no rootname part, when this is
required.  The rootname is a pathname with the extension of the last segment stripped.  Examples:

@example
"/path/to/file.ext"     @result{} "/path/to/file"
"/path/to/file"         @result{} "/path/to/file"
"/path/to/dir/"         @result{} "/path/to/dir"
"file.ext"              @result{} "file.ext"
".fvwmrc"               @result{} ".fvwmrc"
"."                     @error{} missing rootname
".."                    @error{} missing rootname
@end example

There should be only one @emph{no rootname} condition object: the one predefined by @value{PACKAGE}.

All the following definitions are accessible from the header file @file{ccpathnames.h}.


@deftp {Struct Typedef} ccptn_descriptor_no_rootname_t
Structure type representing the descriptor for @emph{no rootname} condition objects.  This
descriptor has @objtype{ccptn_descriptor_invalid_pathname_t} as parent descriptor.
@end deftp


@deftp {Struct Typedef} ccptn_condition_no_rootname_t
Structure type representing an @emph{no rootname} condition object.
@end deftp


@deftypefun void ccptn_condition_init_no_rootname (ccptn_condition_no_rootname_t * @var{C})
Initialise an already allocated condition object.  This function exists to allow sub--typing from
@objtype{ccptn_condition_no_rootname_t}.
@end deftypefun


@deftypefun {cce_condition_t const *} ccptn_condition_new_no_rootname (void)
Return a pointer to the statically allocated structure representing the single @emph{no rootname}
condition object.
@end deftypefun


@deftypefun bool ccptn_condition_is_no_rootname (cce_condition_t const * @var{C})
Return @ctrue{} if @var{C} is an @emph{no rootname} condition object; otherwise return @cfalse{}.
@end deftypefun

@c page
@node memory
@chapter Custom memory allocation


@value{PACKAGE} exposes an @api{} to allow the use of a custom allocator for the pathnames.


@deftp {Struct Typedef} ccptn_allocator_t
The type of a custom memory allocator.  It has the following public fields:

@table @code
@item ccptn_malloc_fun_t * malloc
Pointer to a function used to allocate memory.

@item ccptn_free_fun_t * free
Pointer to a function used to release allocated memory.
@end table
@end deftp


@deftypefn {Function Pointer} {void *} ccptn_malloc_fun_t (ccptn_allocator_t const * @var{A}, cce_destination_t @var{L}, size_t @var{size})
Type of function used to allocate memory.  Basically it works like the standard @cfunc{malloc}, but
if allocation fails: it raises an exception by performing a non--local exit to @var{L}.  The
argument @var{A} is a pointer to the allocator itself.
@end deftypefn


@deftypefn {Function Pointer} void ccptn_free_fun_t (ccptn_allocator_t const * @var{A}, void * @var{ptr})
Type of function used to release allocated memory.  Basically it works like the standard
@cfunc{free}.  The argument @var{A} is a pointer to the allocator itself.
@end deftypefn


@deftypevr {Constant} {ccptn_allocator_t const * const} ccptn_default_allocator
Default allocator predefined by @value{PACKAGE}.  At the core it uses the standard @cfunc{malloc}
and @cfunc{free}.
@end deftypevr


@deftypevar {ccptn_allocator_t const *} ccptn_current_allocator
Currently selected custom memory allocator.  It is initialised with @code{ccptn_default_allocator}.
@end deftypevar


@deftypefun {void *} ccptn_malloc (cce_destination_t @var{L}, size_t @var{size})
Allocate memory using the currently selected memory allocator.
@end deftypefun


@deftypefun void ccptn_free (void * @var{ptr})
Release allocated memory using the currently selected memory allocator.
@end deftypefun

@c page
@node typedefs
@chapter Type definitions


@deftp {Struct Typedef} ccptn_t
Structure representing a Unix pathname.  All the fields are opaque.  All the instances of this type
are immutable.

The pathname is internally represented with an @asciiz{} string.  All the octets in the range
@math{[1, 255]} are valid for the pathname.  A pathname is never empty: it always contains at least
one octet.

Instances of this type include a pointer to function referencing a finalisation function appropriate
for the internal data.  We can always release the resources associated to an instance of
@objtype{ccptn_t} by applying to it the function @cfunc{ccptn_delete}.
@end deftp

@c page
@node ctors
@chapter Constructing pathname representations


@menu
* ctors asciiz::                Pathnames from @asciiz{} strings.
* ctors ascii::                 Pathnames from @ascii{} strings.
@end menu

@c page
@node ctors asciiz
@section Pathnames from @asciiz{} strings


@deftypefun {ccptn_t *} ccptn_new_nodup_asciiz (cce_destination_t @var{L}, char const * @var{pathname})
Allocate a new @objtype{ccptn_t} instance initialising it with data from the @asciiz{} string
@var{pathname}, return a pointer to it.  If an error occurs: raise an exception by performing a
non--local exit to to @var{L}.

The data is @strong{not} duplicated: the returned @objtype{ccptn_t} references @var{pathname}
itself.  Memory is allocated with @cfunc{ccptn_malloc}.  The finalisation function registered in the
instance will release the @code{struct} itself, but not the data buffer.

As usage example see the following code:

@example
cce_location_t        L[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const *  pathname = "/path/to/file.ext";
  ccptn_t *     P;

  P = ccptn_new_nodup_asciiz(L, pathname);
  printf("%s\n", ccptn_asciiz(P));
  ccptn_delete(P);
  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun {ccptn_t *} ccptn_new_dup_asciiz (cce_destination_t @var{L}, char const * @var{pathname})
Allocate a new @objtype{ccptn_t} instance initialising it with data from the @asciiz{} string
@var{pathname}, return a pointer to it.  If an error occurs: raise an exception by performing a
non--local exit to to @var{L}.

The data @strong{is} duplicated: the returned @objtype{ccptn_t} includes a copy of the data from
@var{pathname}.  Memory is allocated with @cfunc{ccptn_malloc}.  The finalisation function
registered in the instance will release the @code{struct} itself, and the data buffer.

As usage example see the following code:

@example
cce_location_t        L[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const *  pathname = "/path/to/file.ext";
  ccptn_t *     P;

  P = ccptn_new_dup_asciiz(L, pathname);
  printf("%s\n", ccptn_asciiz(P));
  ccptn_delete(P);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun {ccptn_t *} ccptn_new_normal_asciiz (cce_destination_t @var{L}, char const * @var{pathname})
Allocate a new @objtype{ccptn_t} instance initialising it with data from the @asciiz{} string
@var{pathname}, return a pointer to it.  If an error occurs: raise an exception by performing a
non--local exit to to @var{L}.

The data @strong{is} duplicated and the pathname is normalised, @ref{manipulations normalise,
Normalising pathnames}.  Memory is allocated with @cfunc{ccptn_malloc}.  The finalisation function
registered in the instance will release the @code{struct} itself, and the data buffer.

As usage example see the following code:

@example
cce_location_t        L[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const *  pathname = "/path/to/file.ext";
  ccptn_t *     P;

  P = ccptn_new_normal_asciiz(L, pathname);
  @{
    printf("%s\n", ccptn_asciiz(P));
  @}
  ccptn_delete(P);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun {ccptn_t *} ccptn_init_nodup_asciiz (cce_destination_t @var{L}, ccptn_t * @var{P}, char const * @var{pathname})
Initialise an already allocated @objtype{ccptn_t} instance with data from the @asciiz{} string
@var{pathname}.  If an error occurs: raise an exception by performing a non--local exit to to
@var{L}.

The data is @strong{not} duplicated: the instance references @var{pathname} itself.  Memory is
allocated with @cfunc{ccptn_malloc}.  The finalisation function registered in the instance will do
nothing.

As usage example see the following code:

@example
cce_location_t        L[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const *  pathname = "/path/to/file.ext";
  ccptn_t       P[1];

  ccptn_init_nodup_asciiz(L, P, pathname);
  printf("%s\n", ccptn_asciiz(P));
  ccptn_delete(P);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun {ccptn_t *} ccptn_init_dup_asciiz (cce_destination_t @var{L}, ccptn_t * @var{P}, char const * @var{pathname})
Initialise an already allocated @objtype{ccptn_t} instance with data from the @asciiz{} string
@var{pathname}.  If an error occurs: raise an exception by performing a non--local exit to to
@var{L}.

The data @strong{is} duplicated: the instance includes a copy of the data from @var{pathname}.
Memory is allocated with @cfunc{ccptn_malloc}.  The finalisation function registered in the instance
will release the data area but not the @code{struct} itself.

As usage example see the following code:

@example
cce_location_t        L[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const *  pathname = "/path/to/file.ext";
  ccptn_t       P[1];

  ccptn_init_dup_asciiz(L, P, pathname);
  printf("%s\n", ccptn_asciiz(P));
  ccptn_delete(P);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun {ccptn_t *} ccptn_init_normal_asciiz (cce_destination_t @var{L}, ccptn_t * @var{P}, char const * @var{pathname})
Initialise an already allocated @objtype{ccptn_t} instance with data from the @asciiz{} string
@var{pathname}.  If an error occurs: raise an exception by performing a non--local exit to to
@var{L}.

The data @strong{is} duplicated and the pathname is normalised, @ref{manipulations normalise,
Normalising pathnames}.  Memory is allocated with @cfunc{ccptn_malloc}.  The finalisation function
registered in the instance will release the data area but not the @code{struct} itself.

As usage example see the following code:

@example
cce_location_t        L[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const *  pathname = "/path/to/file.ext";
  ccptn_t       P[1];

  ccptn_init_normal_asciiz(L, P, pathname);
  @{
    printf("%s\n", ccptn_asciiz(P));
  @}
  ccptn_delete(P);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun

@c page
@node ctors ascii
@section Pathnames from @ascii{} strings


@deftypefun {ccptn_t *} ccptn_new_dup_ascii (cce_destination_t @var{L}, char const * @var{pathname}, size_t @var{len})
Allocate a new @objtype{ccptn_t} instance initialising it with data from the @ascii{} string
@var{pathname} which holds @var{len} octets without terminating zero, return a pointer to it.  If an
error occurs: raise an exception by performing a non--local exit to to @var{L}.

The data @strong{is} duplicated: the returned @objtype{ccptn_t} includes a copy of the data from
@var{pathname}.  Memory is allocated with @cfunc{ccptn_malloc}.  The finalisation function
registered in the instance will release the @code{struct} itself, and the data buffer.

As usage example see the following code:

@example
cce_location_t        L[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const *  pathname = "/path/to/file.ext";
  ccptn_t *     P;

  P = ccptn_new_dup_ascii(L, pathname, strlen(pathname));
  printf("%s\n", ccptn_asciiz(P));
  ccptn_delete(P);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun {ccptn_t *} ccptn_new_normal_ascii (cce_destination_t @var{L}, char const * @var{pathname}, size_t @var{len})
Allocate a new @objtype{ccptn_t} instance initialising it with data from the @ascii{} string
@var{pathname} which holds @var{len} octets without terminating zero, return a pointer to it.  If an
error occurs: raise an exception by performing a non--local exit to to @var{L}.

The data @strong{is} duplicated and the pathname is normalised, @ref{manipulations normalise,
Normalising pathnames}.  Memory is allocated with @cfunc{ccptn_malloc}.  The finalisation function
registered in the instance will release the @code{struct} itself, and the data buffer.

As usage example see the following code:

@example
cce_location_t        L[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const *  pathname = "/path/to/file.ext";
  ccptn_t *     P;

  P = ccptn_new_normal_ascii(L, pathname, strlen(pathname));
  printf("%s\n", ccptn_asciiz(P));
  ccptn_delete(P);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun {ccptn_t *} ccptn_init_dup_ascii (cce_destination_t @var{L}, ccptn_t * @var{P}, char const * @var{pathname}, size_t @var{len})
Initialise an already allocated @objtype{ccptn_t} instance with data from the @ascii{} string
@var{pathname} which holds @var{len} octets without terminating zero.  If an error occurs: raise an
exception by performing a non--local exit to to @var{L}.

The data @strong{is} duplicated: the instance includes a copy of the data from @var{pathname}.
Memory is allocated with @cfunc{ccptn_malloc}.  The finalisation function registered in the instance
will release the data area but not the @code{struct} itself.

As usage example see the following code:

@example
cce_location_t        L[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const *  pathname = "/path/to/file.ext";
  ccptn_t       P[1];

  ccptn_init_dup_ascii(L, P, pathname, strlen(pathname));
  printf("%s\n", ccptn_asciiz(P));
  ccptn_delete(P);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun {ccptn_t *} ccptn_init_normal_ascii (cce_destination_t @var{L}, ccptn_t * @var{P}, char const * @var{pathname}, size_t @var{len})
Initialise an already allocated @objtype{ccptn_t} instance with data from the @ascii{} string
@var{pathname} which holds @var{len} octets without terminating zero.  If an error occurs: raise an
exception by performing a non--local exit to to @var{L}.

The data @strong{is} duplicated and the pathname is normalised, @ref{manipulations normalise,
Normalising pathnames}.  Memory is allocated with @cfunc{ccptn_malloc}.  The finalisation function
registered in the instance will release the data area but not the @code{struct} itself.

As usage example see the following code:

@example
cce_location_t        L[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const *  pathname = "/path/to/file.ext";
  ccptn_t       P[1];

  ccptn_init_normal_ascii(L, P, pathname, strlen(pathname));
  printf("%s\n", ccptn_asciiz(P));
  ccptn_delete(P);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun

@c page
@node dtors
@chapter Destructing pathname representations


@deftypefun void ccptn_delete (ccptn_t * @var{P})
Release all the resources associated to the referenced instance of @objtype{ccptn_t}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Using exception handlers


@value{PACKAGE} is linked to the CCExceptions library to handle errors by raising exceptions; we can
use exception handlers to release @objtype{ccptn_t} instances upon exiting a local context.


@deftypefun void ccptn_clean_handler_ptn_init (cce_destination_t @var{L}, cce_handler_t * @var{H}, ccptn_t * @var{P})
@deftypefunx void ccptn_error_handler_ptn_init (cce_destination_t @var{L}, cce_handler_t * @var{H}, ccptn_t * @var{P})
Register @var{H} as clean or error handler in the context of @var{L}.  The handler function will
finalise the pathname referenced by @var{P}.  If an error occurs while configuring the handler: an
exception is raised by performing a non--local exit to @var{L}.
@end deftypefun


@deftypefn {Preprocessor Macro} void ccptn_handler_ptn_init (cce_destination_t @var{L}, cce_clean_handler_t * @var{H}, ccptn_t * @var{P})
@deftypefnx {Preprocessor Macro} void ccptn_handler_ptn_init (cce_destination_t @var{L}, cce_error_handler_t * @var{H}, ccptn_t * @var{P})
This preprocessor macro uses @code{_Generic} to dispatch the call according to the type of the
pointer @var{H}; if the type is:

@table @code
@item cce_clean_handler_t
The macro expands into a call to @cfunc{ccptn_clean_handler_ptn_init}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccptn_error_handler_ptn_init}.
@end table
@end deftypefn


As usage example of the exception handler, see the following code:

@example
cce_location_t        L[1];
cce_clean_handler_t P_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const *  pathname = "/path/to/file.ext";
  ccptn_t *     P;

  P = ccptn_new_nodup_asciiz(L, pathname);
  ccptn_handler_ptn_init(L, P_H, P);

  printf("%s\n", ccptn_asciiz(P));
  cce_run_body_handlers(L);
@}
@end example

@c page
@node guarded
@chapter Guarded constructors


@subsubheading Constructors with error handlers


@deftypefun {ccptn_t *} ccptn_init_nodup_asciiz_guarded_error (cce_destination_t @var{L}, ccptn_t * @var{P}, cce_error_handler_t * @var{H}, char const * @var{pathname})
Like @cfunc{ccptn_init_nodup_asciiz}, but register the resulting @objtype{ccptn_t} to be released by
the error handler @var{H}.
@end deftypefun


@deftypefun {ccptn_t *} ccptn_init_dup_asciiz_guarded_error (cce_destination_t @var{L}, ccptn_t * @var{P}, cce_error_handler_t * @var{H}, char const * @var{pathname})
Like @cfunc{ccptn_init_dup_asciiz}, but register the resulting @objtype{ccptn_t} to be released by
the error handler @var{H}.
@end deftypefun


@deftypefun {ccptn_t *} ccptn_init_normal_asciiz_guarded_error (cce_destination_t @var{L}, ccptn_t * @var{P}, cce_error_handler_t * @var{H}, char const * @var{pathname})
Like @cfunc{ccptn_init_normal_asciiz}, but register the resulting @objtype{ccptn_t} to be released
by the error handler @var{H}.
@end deftypefun


@deftypefun {ccptn_t *} ccptn_new_nodup_asciiz_guarded_error (cce_destination_t @var{L}, cce_error_handler_t * @var{H}, char const * @var{pathname})
Like @cfunc{ccptn_new_nodup_asciiz}, but register the resulting @objtype{ccptn_t} to be released by
the error handler @var{H}.
@end deftypefun


@deftypefun {ccptn_t *} ccptn_new_dup_asciiz_guarded_error (cce_destination_t @var{L}, cce_error_handler_t * @var{H}, char const * @var{pathname})
Like @cfunc{ccptn_new_dup_asciiz}, but register the resulting @objtype{ccptn_t} to be released by
the error handler @var{H}.
@end deftypefun


@deftypefun {ccptn_t *} ccptn_new_normal_asciiz_guarded_error (cce_destination_t @var{L}, cce_error_handler_t * @var{H}, char const * @var{pathname})
Like @cfunc{ccptn_new_normal_asciiz}, but register the resulting @objtype{ccptn_t} to be released by
the error handler @var{H}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Constructors with clean handlers


@deftypefun {ccptn_t *} ccptn_init_nodup_asciiz_guarded_clean (cce_destination_t @var{L}, ccptn_t * @var{P}, cce_clean_handler_t * @var{H}, char const * @var{pathname})
Like @cfunc{ccptn_init_nodup_asciiz}, but register the resulting @objtype{ccptn_t} to be released by
the clean handler @var{H}.
@end deftypefun


@deftypefun {ccptn_t *} ccptn_init_dup_asciiz_guarded_clean (cce_destination_t @var{L}, ccptn_t * @var{P}, cce_clean_handler_t * @var{H}, char const * @var{pathname})
Like @cfunc{ccptn_init_dup_asciiz}, but register the resulting @objtype{ccptn_t} to be released by
the clean handler @var{H}.
@end deftypefun


@deftypefun {ccptn_t *} ccptn_init_normal_asciiz_guarded_clean (cce_destination_t @var{L}, ccptn_t * @var{P}, cce_clean_handler_t * @var{H}, char const * @var{pathname})
Like @cfunc{ccptn_init_normal_asciiz}, but register the resulting @objtype{ccptn_t} to be released
by the clean handler @var{H}.
@end deftypefun


@deftypefun {ccptn_t *} ccptn_new_nodup_asciiz_guarded_clean (cce_destination_t @var{L}, cce_clean_handler_t * @var{H}, char const * @var{pathname})
Like @cfunc{ccptn_new_nodup_asciiz}, but register the resulting @objtype{ccptn_t} to be released by
the clean handler @var{H}.
@end deftypefun


@deftypefun {ccptn_t *} ccptn_new_dup_asciiz_guarded_clean (cce_destination_t @var{L}, cce_clean_handler_t * @var{H}, char const * @var{pathname})
Like @cfunc{ccptn_new_dup_asciiz}, but register the resulting @objtype{ccptn_t} to be released by
the clean handler @var{H}.
@end deftypefun


@deftypefun {ccptn_t *} ccptn_new_normal_asciiz_guarded_clean (cce_destination_t @var{L}, cce_clean_handler_t * @var{H}, char const * @var{pathname})
Like @cfunc{ccptn_new_normal_asciiz}, but register the resulting @objtype{ccptn_t} to be released by
the clean handler @var{H}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Generic guarded constructors


@deftypefn {Preprocessor Macro} {ccptn_t *} ccptn_init_nodup_asciiz_guarded (cce_destination_t @var{L}, ccptn_t * P, @var{H}, char const * @var{pathname})
This macro uses @code{_Generic} to dispatch the expansion according to the type of @var{H}; if the
type is a pointer to:

@table @code
@item cce_clean_handler_t
The macro expands into a call to @cfunc{ccptn_init_nodup_asciiz_guarded_clean}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccptn_init_nodup_asciiz_guarded_error}.
@end table
@end deftypefn


@deftypefn {Preprocessor Macro} {ccptn_t *} ccptn_init_dup_asciiz_guarded (cce_destination_t @var{L}, ccptn_t * P, @var{H}, char const * @var{pathname})
This macro uses @code{_Generic} to dispatch the expansion according to the type of @var{H}; if the
type is a pointer to:

@table @code
@item cce_clean_handler_t
The macro expands into a call to @cfunc{ccptn_init_dup_asciiz_guarded_clean}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccptn_init_dup_asciiz_guarded_error}.
@end table
@end deftypefn


@deftypefn {Preprocessor Macro} {ccptn_t *} ccptn_init_normal_asciiz_guarded (cce_destination_t @var{L}, ccptn_t * P, @var{H}, char const * @var{pathname})
This macro uses @code{_Generic} to dispatch the expansion according to the type of @var{H}; if the
type is a pointer to:

@table @code
@item cce_clean_handler_t
The macro expands into a call to @cfunc{ccptn_init_normal_asciiz_guarded_clean}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccptn_init_normal_asciiz_guarded_error}.
@end table
@end deftypefn


@deftypefn {Preprocessor Macro} {ccptn_t *} ccptn_new_nodup_asciiz_guarded (cce_destination_t @var{L}, @var{H}, char const * @var{pathname})
This macro uses @code{_Generic} to dispatch the expansion according to the type of @var{H}; if the
type is a pointer to:

@table @code
@item cce_clean_handler_t
The macro expands into a call to @cfunc{ccptn_new_nodup_asciiz_guarded_clean}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccptn_new_nodup_asciiz_guarded_error}.
@end table
@end deftypefn


@deftypefn {Preprocessor Macro} {ccptn_t *} ccptn_new_dup_asciiz_guarded (cce_destination_t @var{L}, @var{H}, char const * @var{pathname})
This macro uses @code{_Generic} to dispatch the expansion according to the type of @var{H}; if the
type is a pointer to:

@table @code
@item cce_clean_handler_t
The macro expands into a call to @cfunc{ccptn_new_dup_asciiz_guarded_clean}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccptn_new_dup_asciiz_guarded_error}.
@end table
@end deftypefn


@deftypefn {Preprocessor Macro} {ccptn_t *} ccptn_new_normal_asciiz_guarded (cce_destination_t @var{L}, @var{H}, char const * @var{pathname})
This macro uses @code{_Generic} to dispatch the expansion according to the type of @var{H}; if the
type is a pointer to:

@table @code
@item cce_clean_handler_t
The macro expands into a call to @cfunc{ccptn_new_normal_asciiz_guarded_clean}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccptn_new_normal_asciiz_guarded_error}.
@end table
@end deftypefn

@c page
@node predicates
@chapter Pathname predicates


@deftypefun bool ccptn_is_absolute (ccptn_t const * @var{P})
Return @ctrue{} if @var{P} represents an absolute pathname; otherwise return @cfalse{}.  A pathname
is absolute if its first octet is the @ascii{} representation of @samp{/}.
@end deftypefun


@deftypefun bool ccptn_is_relative (ccptn_t const * @var{P})
Return @ctrue{} if @var{P} represents a relative pathname; otherwise return @cfalse{}.  A pathname
is relative if its first octet is @strong{not} the @ascii{} representation of @samp{/}.
@end deftypefun


@deftypefun bool ccptn_is_realpath (ccptn_t const * @var{P})
Return @ctrue{} if @var{P} is the result of a call to the system function @cfunc{realpath};
otherwise return @cfalse{}.
@end deftypefun


@deftypefun bool ccptn_is_normalised (ccptn_t const * @var{P})
Return @ctrue{} if @var{P} is the result of either a call to the system function @cfunc{realpath} or
to one of the normalisation functions; otherwise return @cfalse{}.
@end deftypefun

@c page
@node accessors
@chapter Pathname accessors


@deftypefun {char const *} ccptn_asciiz (ccptn_t const * @var{P})
Return a pointer to an @asciiz{} representation of the pathname.
@end deftypefun


@deftypefun size_t ccptn_len (ccptn_t const * @var{P})
Return the number of octets in the pathname representation, @strong{not} including the terminating
zero.
@end deftypefun

@c page
@node manipulations
@chapter Pathname manipulations


@menu
* manipulations realpath::      Obtaining the real pathname.
* manipulations normalise::     Normalising pathnames.
* manipulations concat::        Concatenating pathnames.
@end menu

@c page
@node manipulations realpath
@section Obtaining the real pathname


@deftypefun {ccptn_t *} ccptn_new_realpath (cce_destination_t @var{L}, ccptn_t const * @var{P})
Build and return a new @objtype{ccptn_t} instance representing the result of applying the standard
@cfunc{realpath} to the pathname represented by @var{P}.  If an error occurs: raise an exception by
performing a non--local exit to to @var{L}.

Notice that the pathname has to exist for this function to succeed.

As usage example, see the following code.

@example
cce_location_t          L[1];
cce_clean_handler_t   P_H[1], Q_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const *  pathname = "/path/to/file.ext";
  ccptn_t       *P, *Q;

  P = ccptn_new_nodup_asciiz(L, pathname);
  ccptn_handler_ptn_init(L, P_H, P);

  Q = ccptn_new_realpath(L, P);
  ccptn_handler_ptn_init(L, Q_H, Q);

  /* do something with Q */

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun {ccptn_t *} ccptn_init_realpath (cce_destination_t @var{L}, ccptn_t * @var{R}, ccptn_t const * @var{P})
Initialise the already allocated @objtype{ccptn_t} instance, referenced by @var{R}, representing the
result of applying the standard @cfunc{realpath} to the pathname represented by @var{P}.  Return
@var{R} itself.  If an error occurs: raise an exception by performing a non--local exit to to
@var{L}.

Notice that the pathname has to exist for this function to succeed.

As usage example, see the following code.

@example
cce_location_t          L[1];
cce_clean_handler_t   P_H[1], Q_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const *  pathname = "/path/to/file.ext";
  ccptn_t       *P, R[1];

  P = ccptn_new_nodup_asciiz(L, pathname);
  ccptn_handler_ptn_init(L, P_H, P);

  ccptn_init_realpath(L, R, P);
  ccptn_handler_ptn_init(L, R_H, R);

  /* do something with R */

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Guarded pathnames with error handlers


@deftypefun {ccptn_t *} ccptn_new_realpath_guarded_error (cce_destination_t @var{L}, cce_error_handler_t * @var{H}, ccptn_t const * @var{P})
Like @cfunc{ccptn_new_realpath}, but register the resulting instance of @objtype{ccptn_t} for
finalisation in the error handler @var{H}.
@end deftypefun


@deftypefun {ccptn_t *} ccptn_init_realpath_guarded_error (cce_destination_t @var{L}, ccptn_t * @var{R}, cce_error_handler_t * @var{H}, ccptn_t const * @var{P})
Like @cfunc{ccptn_init_realpath}, but register the resulting instance of @objtype{ccptn_t} for
finalisation in the error handler @var{H}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Guarded pathnames with clean handlers


@deftypefun {ccptn_t *} ccptn_new_realpath_guarded_clean (cce_destination_t @var{L}, cce_clean_handler_t * @var{H}, ccptn_t const * @var{P})
Like @cfunc{ccptn_new_realpath}, but register the resulting instance of @objtype{ccptn_t} for
finalisation in the clean handler @var{H}.
@end deftypefun


@deftypefun {ccptn_t *} ccptn_init_realpath_guarded_clean (cce_destination_t @var{L}, ccptn_t * @var{R}, cce_clean_handler_t * @var{H}, ccptn_t const * @var{P})
Like @cfunc{ccptn_init_realpath}, but register the resulting instance of @objtype{ccptn_t} for
finalisation in the clean handler @var{H}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Generic preprocessor macros


@deftypefn {Preprocessor Macro} {ccptn_t *} ccptn_new_realpath_guarded (cce_destination_t @var{L}, @var{H}, ccptn_t const * @var{P})
This macro uses @code{_Generic} to dispatch its expansion according to the type of @var{H}; if the
type is a pointer to:

@table @code
@item cce_clean_handler_t
The macro expands into a call to @cfunc{ccptn_new_realpath_guarded_clean}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccptn_new_realpath_guarded_error}.
@end table
@end deftypefn


@deftypefn {Preprocessor Macro} {ccptn_t *} ccptn_init_realpath_guarded (cce_destination_t @var{L}, ccptn_t * @var{R}, @var{H}, ccptn_t const * @var{P})
This macro uses @code{_Generic} to dispatch its expansion according to the type of @var{H}; if the
type is a pointer to:

@table @code
@item cce_clean_handler_t
The macro expands into a call to @cfunc{ccptn_init_realpath_guarded_clean}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccptn_init_realpath_guarded_error}.
@end table
@end deftypefn

@c page
@node manipulations normalise
@section Normalising pathnames


A normalised pathname: has no multiple slashes; has no useless terminating slash; has no useless
single--dot components; has the double--dot components removed as much as possible.  Examples:

@example
/                       @result{} /
file.ext                @result{} file.ext
/path/to/file.ext       @result{} /path/to/file.ext
//                      @result{} /
/path///to///file.ext   @result{} /path/to/file.ext
/path/to/dir/           @result{} /path/to/dir/
/path/to/././file.ext   @result{} /path/to/file.ext
/path/to/.              @result{} /path/to
/.                      @result{} /
.                       @result{} .
/path/to/../file.ext    @result{} /path/file.ext
/path/../../to/file.ext @result{} ../to/file.ext
..                      @result{} ..
/..                     @error{} invalid pathname
@end example

Some notes on the normalisation:

@itemize
@item
We do not want to remove an ending slash octet, unless the whole pathname is @file{./} or
@file{../}.  This is because a pathname like @file{a/b/} is meant to represent a directory, while
@file{a/b} can represent a non--directory too.

@item
We do not want to fully remove a directory part.  This is because @file{./file.ext} may represent an
executable file in the current directory, while @file{file.ext} may represent an executable pathname
in any of the directories selected by the value in the environment variable @env{PATH}.  So we want
the following normalisations:

@example
./file.ext              @result{} ./file.ext
../path/file.ext        @result{} ./file.ext
@end example
@end itemize


@deftypefun {ccptn_t *} ccptn_new_normalise (cce_destination_t @var{L}, ccptn_t const * @var{P})
Build and return a new instance of @objtype{ccptn_t} representing the normalisation of @var{P}.  If
an error occurs: raise an exception by performing a non--local exit to to @var{L}.
@end deftypefun


@deftypefun {ccptn_t *} ccptn_init_normalise (cce_destination_t @var{L}, ccptn_t * @var{R}, ccptn_t const * @var{P})
Initialise an already allocated instance of @objtype{ccptn_t}, referenced by @var{R}, with the
representation of the normalisation of @var{P}.  If an error occurs: raise an exception by
performing a non--local exit to to @var{L}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Low level functions


@deftypefun size_t ccptn_normal_pass_remove_useless_slashes (char * @var{output_ptr}, char const * @var{input_ptr}, size_t @var{input_len})
Copy a pathname from @var{input_ptr} to @var{output_ptr} performing a normalisation pass in the
process: removal of multiple slashes.

The array referenced by @var{input_ptr} must represent an @asciiz{} string with at least
@var{input_len} octets, terminating zero excluded.  The array referenced by @var{output_ptr} must be
at least @code{1 + @var{input_len}} octets wide.

Return the number of octets stored in the array referenced by @var{output_ptr}, terminating zero
excluded.
@end deftypefun


@deftypefun size_t ccptn_normal_pass_remove_single_dot_segments (char * @var{output_ptr}, char const * @var{input_ptr}, size_t @var{input_len})
Copy a pathname from @var{input_ptr} to @var{output_ptr} performing a normalisation pass in the
process: removal of single--dot segments.  This pass is meant to be applied after
@cfunc{ccptn_normal_pass_remove_useless_slashes}.

The array referenced by @var{input_ptr} must represent an @asciiz{} string with at least
@var{input_len} octets, terminating zero excluded.  The array referenced by @var{output_ptr} must be
at least @code{1 + @var{input_len}} octets wide.

Return the number of octets stored in the array referenced by @var{output_ptr}, terminating zero
excluded.
@end deftypefun


@deftypefun size_t ccptn_normal_pass_remove_double_dot_segments (cce_destination_t @var{L}, char * @var{output_ptr}, char const * @var{input_ptr}, size_t @var{input_len})
Copy a pathname from @var{input_ptr} to @var{output_ptr} performing a normalisation pass in the
process: removal of double--dot segments and the segments before them.  This pass is meant to be
applied after @cfunc{ccptn_normal_pass_remove_single_dot_segments}.

The array referenced by @var{input_ptr} must represent an @asciiz{} string with at least
@var{input_len} octets, terminating zero excluded.  The array referenced by @var{output_ptr} must be
at least @code{1 + @var{input_len}} octets wide.

If successful: return the number of octets stored in the array referenced by @var{output_ptr},
terminating zero excluded.  If a double--dot segment has no segment before, representing an invalid
pathname: raise an exception by performing a non--local exit to @var{L}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Guarded pathnames with error handlers


@deftypefun {ccptn_t *} ccptn_new_normalise_guarded_error (cce_destination_t @var{L}, cce_error_handler_t * @var{H}, ccptn_t const * @var{P})
Like @cfunc{ccptn_new_normalise}, but register the resulting instance of @objtype{ccptn_t} for
finalisation in the error handler @var{H}.
@end deftypefun


@deftypefun {ccptn_t *} ccptn_init_normalise_guarded_error (cce_destination_t @var{L}, ccptn_t * @var{R}, cce_error_handler_t * @var{H}, ccptn_t const * @var{P})
Like @cfunc{ccptn_init_normalise}, but register the resulting instance of @objtype{ccptn_t} for
finalisation in the error handler @var{H}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Guarded pathnames with clean handlers


@deftypefun {ccptn_t *} ccptn_new_normalise_guarded_clean (cce_destination_t @var{L}, cce_clean_handler_t * @var{H}, ccptn_t const * @var{P})
Like @cfunc{ccptn_new_normalise}, but register the resulting instance of @objtype{ccptn_t} for
finalisation in the clean handler @var{H}.
@end deftypefun


@deftypefun {ccptn_t *} ccptn_init_normalise_guarded_clean (cce_destination_t @var{L}, ccptn_t * @var{R}, cce_clean_handler_t * @var{H}, ccptn_t const * @var{P})
Like @cfunc{ccptn_init_normalise}, but register the resulting instance of @objtype{ccptn_t} for
finalisation in the clean handler @var{H}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Generic preprocessor macros


@deftypefn {Preprocessor Macro} {ccptn_t *} ccptn_new_normalise_guarded (cce_destination_t @var{L}, @var{H}, ccptn_t const * @var{P})
This macro uses @code{_Generic} to dispatch its expansion according to the type of @var{H}; if the
type is a pointer to:

@table @code
@item cce_clean_handler_t
The macro expands into a call to @cfunc{ccptn_new_normalise_guarded_clean}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccptn_new_normalise_guarded_error}.
@end table
@end deftypefn


@deftypefn {Preprocessor Macro} {ccptn_t *} ccptn_init_normalise_guarded (cce_destination_t @var{L}, ccptn_t * @var{R}, @var{H}, ccptn_t const * @var{P})
This macro uses @code{_Generic} to dispatch its expansion according to the type of @var{H}; if the
type is a pointer to:

@table @code
@item cce_clean_handler_t
The macro expands into a call to @cfunc{ccptn_init_normalise_guarded_clean}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccptn_init_normalise_guarded_error}.
@end table
@end deftypefn

@c page
@node manipulations concat
@section Concatenating pathnames


@deftypefun {ccptn_t *} ccptn_new_concat (cce_destination_t @var{L}, ccptn_t const * @var{prefix}, ccptn_t const * @var{suffix})
Build and return a new instance of @objtype{ccptn_t} representing the result of concatenating the
@var{prefix} and the @var{suffix}.  If an error occurs: raise an exception by performing a
non--local exit to to @var{L}.

@example
cce_location_t        L[1];
cce_clean_handler_t P1_H[1], P2_H[1], R_H[1];

if (cce_location(L)) @{
  cce_run_catch_handlers_final(L);
@} else @{
  char const * pathname_1 = "/path/to";
  char const * pathname_2 = "file.ext";
  ccptn_t      *P1, *P2, *R;

  P1 = ccptn_new_nodup_asciiz_guarded(L, P1_H, pathname_1);
  P2 = ccptn_new_nodup_asciiz_guarded(L, P2_H, pathname_2);
  R  = ccptn_new_concat(L, P1, P2);
  ccptn_handler_ptn_init(L, R_H, R);

  cce_run_body_handlers(L);
@}
@end example
@end deftypefun


@deftypefun {ccptn_t *} ccptn_init_concat (cce_destination_t @var{L}, ccptn_t * @var{R}, ccptn_t const * @var{prefix}, ccptn_t const * @var{suffix})
Initialise the already allocated instance of @objtype{ccptn_t}, referenced by @var{R}, with the
representation of the concatenation between the @var{prefix} and the @var{suffix}.  Return @var{R}
itself.  If an error occurs: raise an exception by performing a non--local exit to to @var{L}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Guarded pathnames with error handlers


@deftypefun {ccptn_t *} ccptn_new_concat_guarded_error (cce_destination_t @var{L}, cce_error_handler_t * @var{H}, ccptn_t const * @var{prefix}, ccptn_t const * @var{suffix})
Like @cfunc{ccptn_new_concat}, but register the resulting instance of @objtype{ccptn_t} for
finalisation in the error handler @var{H}.
@end deftypefun


@deftypefun {ccptn_t *} ccptn_init_concat_guarded_error (cce_destination_t @var{L}, ccptn_t * @var{R}, cce_error_handler_t * @var{H}, ccptn_t const * @var{prefix}, ccptn_t const * @var{suffix})
Like @cfunc{ccptn_init_concat}, but register the resulting instance of @objtype{ccptn_t} for
finalisation in the error handler @var{H}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Guarded pathnames with clean handlers


@deftypefun {ccptn_t *} ccptn_new_concat_guarded_clean (cce_destination_t @var{L}, cce_clean_handler_t * @var{H}, ccptn_t const * @var{prefix}, ccptn_t const * @var{suffix})
Like @cfunc{ccptn_new_concat}, but register the resulting instance of @objtype{ccptn_t} for
finalisation in the clean handler @var{H}.
@end deftypefun


@deftypefun {ccptn_t *} ccptn_init_concat_guarded_clean (cce_destination_t @var{L}, ccptn_t * @var{R}, cce_clean_handler_t * @var{H}, ccptn_t const * @var{prefix}, ccptn_t const * @var{suffix})
Like @cfunc{ccptn_init_concat}, but register the resulting instance of @objtype{ccptn_t} for
finalisation in the clean handler @var{H}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Generic preprocessor macros


@deftypefn {Preprocessor Macro} {ccptn_t *} ccptn_new_concat_guarded (cce_destination_t @var{L}, @var{H}, ccptn_t const * @var{prefix}, ccptn_t const * @var{suffix})
This macro uses @code{_Generic} to dispatch its expansion according to the type of @var{H}; if the
type is a pointer to:

@table @code
@item cce_clean_handler_t
The macro expands into a call to @cfunc{ccptn_new_concat_guarded_clean}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccptn_new_concat_guarded_error}.
@end table
@end deftypefn


@deftypefn {Preprocessor Macro} {ccptn_t *} ccptn_init_concat_guarded (cce_destination_t @var{L}, ccptn_t * @var{R}, @var{H}, ccptn_t const * @var{prefix}, ccptn_t const * @var{suffix})
This macro uses @code{_Generic} to dispatch its expansion according to the type of @var{H}; if the
type is a pointer to:

@table @code
@item cce_clean_handler_t
The macro expands into a call to @cfunc{ccptn_init_concat_guarded_clean}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccptn_init_concat_guarded_error}.
@end table
@end deftypefn

@c page
@node components
@chapter Pathname components


@menu
* components extensions::       Extracting pathname extensions.
* components rootnames::        Extracting pathname rootnames.
* components dirnames::         Extracting pathname dirnames.
* components tailnames::        Extracting pathname tailnames.
* components filenames::        Extracting pathname filenames.
@end menu

@c page
@node components extensions
@section Extracting pathname extensions


An @dfn{extension} is the last portion of the last segment in an input pathname following the last
dot, but only if it is not the whole segment.  Examples:

@example
"/path/to/file.ext"     => ".ext"
"/path/to/file"         => ""
"/path/to/dir/"         => ""
"/path/to/dir.ext/"     => ".ext"
"file.ext"              => ".ext"
".fvwmrc"               => ""
"."                     => ""
".."                    => ""
"/"                     => ""
@end example

Extension extraction is possible only for an input pathname that has been previously normalised; if
the input is not normalised: the functions below will raise an exception of type
@objtype{ccptn_condition_normalised_pathname_t}.


@deftypefun ccptn_extension_t ccptn_extension (cce_destination_t @var{L}, ccptn_t const * @var{P})
Find the extension of the last segment in the input pathname referenced by @var{P} and return an
instance of @objtype{ccptn_extension_t} representing it; the returned value references the section
of data in the input pathname and so it is valid data only while the input pathname exists.  If an
error occurs: raise an exception by performing a non--local exit to @var{L}.

If the input pathname has no extension: the returned value represents the empty string by having the
length field to zero, while the pointer field references the terminating zero in the @asciiz{}
representation of the input pathname.
@end deftypefun

@c page
@node components rootnames
@section Extracting pathname rootnames


The @dfn{rootname} of an input pathname is a pathname representing the input with the extension of
the last segment stripped.  Examples:

@example
"/path/to/file.ext"     => "/path/to/file"
"/path/to/file"         => "/path/to/file"
"/path/to/dir/"         => "/path/to/dir"
"file.ext"              => "file.ext"
".fvwmrc"               => ".fvwmrc"
"."                     --> error
".."                    --> error
"/"                     --> error
@end example

It is an error to attempt rootname extraction from an input pathname that has no rootname; in this
case the functions below will raise an exception of type @objtype{ccptn_condition_no_rootname_t}.

Rootname extraction is possible only for an input pathname that has been previously normalised; if
the input is not normalised: the functions below will raise an exception of type
@objtype{ccptn_condition_normalised_pathname_t}.


@deftypefun {ccptn_t *} ccptn_new_rootname (cce_destination_t @var{L}, ccptn_t const * @var{P})
Build and return a new instance of @objtype{ccptn_t} representing the rootname of the input pathname
referenced by @var{P}.  If an error occurs: raise an exception by performing a non--local exit to
@var{L}.
@end deftypefun


@deftypefun {ccptn_t *} ccptn_init_rootname (cce_destination_t @var{L}, ccptn_t * @var{R}, ccptn_t const * @var{P})
Initialise an already allocated instance of @objtype{ccptn_t}, referenced by @var{R}, representing
the rootname of the input pathname referenced by @var{P}.  If an error occurs: raise an exception by
performing a non--local exit to @var{L}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Guarded functions for error handlers


@deftypefun {ccptn_t *} ccptn_new_rootname_guarded_error (cce_destination_t @var{L}, cce_error_handler_t * @var{H}, ccptn_t const * @var{P})
Like @cfunc{ccptn_new_rootname}, but register the resulting instance of @objtype{ccptn_t} to be
released by the error handler referenced by @var{H}.
@end deftypefun


@deftypefun {ccptn_t *} ccptn_init_rootname_guarded_error (cce_destination_t @var{L}, ccptn_t * @var{R}, cce_error_handler_t * @var{H}, ccptn_t const * @var{P})
Like @cfunc{ccptn_init_rootname}, but register the resulting instance of @objtype{ccptn_t} to be
released by the error handler referenced by @var{H}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Guarded functions for clean handlers


@deftypefun {ccptn_t *} ccptn_new_rootname_guarded_clean (cce_destination_t @var{L}, cce_clean_handler_t * @var{H}, ccptn_t const * @var{P})
Like @cfunc{ccptn_new_rootname}, but register the resulting instance of @objtype{ccptn_t} to be
released by the clean handler referenced by @var{H}.
@end deftypefun


@deftypefun {ccptn_t *} ccptn_init_rootname_guarded_clean (cce_destination_t @var{L}, ccptn_t * @var{R}, cce_clean_handler_t * @var{H}, ccptn_t const * @var{P})
Like @cfunc{ccptn_init_rootname}, but register the resulting instance of @objtype{ccptn_t} to be
released by the clean handler referenced by @var{H}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Generic preprocessor macros


@deftypefn {Preprocessor Macro} {ccptn_t *} ccptn_new_rootname_guarded (cce_destination_t @var{L}, @var{H}, ccptn_t const * @var{P})
This macro uses @code{_Generic} to dispatch its expansion according to the type of @var{H}; if the
type is a pointer to:

@table @code
@item cce_clean_handler_t
The macro expands into a call to @cfunc{ccptn_new_rootname_guarded_clean}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccptn_new_rootname_guarded_error}.
@end table
@end deftypefn


@deftypefn {Preprocessor Macro} {ccptn_t *} ccptn_init_rootname_guarded (cce_destination_t @var{L}, ccptn_t * @var{R}, @var{H}, ccptn_t const * @var{P})
This macro uses @code{_Generic} to dispatch its expansion according to the type of @var{H}; if the
type is a pointer to:

@table @code
@item cce_clean_handler_t
The macro expands into a call to @cfunc{ccptn_init_rootname_guarded_clean}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccptn_init_rootname_guarded_error}.
@end table
@end deftypefn

@c page
@node components dirnames
@section Extracting pathname dirnames


The @dfn{dirname} is the pathname representing the input pathname with the last segment stripped.
Examples:

@example
"/path/to/file.ext"     @result{} "/path/to"
"/path/to/dir/"         @result{} "/path/to"
"file.ext"              @error{} no dirname
"."                     @result{} ".."
".."                    @error{} no dirname
"/"                     @result{} "/"
@end example

It is an error to attempt dirname extraction from an input pathname that has no dirname; in this
case the functions below will raise an exception of type @objtype{ccptn_condition_no_dirname_t}.

Dirname extraction is possible only for an input pathname that has been previously normalised; if
the input is not normalised: the functions below will raise an exception of type
@objtype{ccptn_condition_normalised_pathname_t}.


@deftypefun {ccptn_t *} ccptn_new_dirname (cce_destination_t @var{L}, ccptn_t const * @var{P})
Build and return a new instance of @objtype{ccptn_t} representing the dirname of the input pathname
referenced by @var{P}.  If an error occurs: raise an exception by performing a non--local exit to
@var{L}.
@end deftypefun


@deftypefun {ccptn_t *} ccptn_init_dirname (cce_destination_t @var{L}, ccptn_t * @var{R}, ccptn_t const * @var{P})
Initialise an already allocated instance of @objtype{ccptn_t}, referenced by @var{R}, representing
the dirname of the input pathname referenced by @var{P}.  If an error occurs: raise an exception by
performing a non--local exit to @var{L}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Guarded functions for error handlers


@deftypefun {ccptn_t *} ccptn_new_dirname_guarded_error (cce_destination_t @var{L}, cce_error_handler_t * @var{H}, ccptn_t const * @var{P})
Like @cfunc{ccptn_new_dirname}, but register the resulting instance of @objtype{ccptn_t} to be
released by the error handler referenced by @var{H}.
@end deftypefun


@deftypefun {ccptn_t *} ccptn_init_dirname_guarded_error (cce_destination_t @var{L}, ccptn_t * @var{R}, cce_error_handler_t * @var{H}, ccptn_t const * @var{P})
Like @cfunc{ccptn_init_dirname}, but register the resulting instance of @objtype{ccptn_t} to be
released by the error handler referenced by @var{H}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Guarded functions for clean handlers


@deftypefun {ccptn_t *} ccptn_new_dirname_guarded_clean (cce_destination_t @var{L}, cce_clean_handler_t * @var{H}, ccptn_t const * @var{P})
Like @cfunc{ccptn_new_dirname}, but register the resulting instance of @objtype{ccptn_t} to be
released by the clean handler referenced by @var{H}.
@end deftypefun


@deftypefun {ccptn_t *} ccptn_init_dirname_guarded_clean (cce_destination_t @var{L}, ccptn_t * @var{R}, cce_clean_handler_t * @var{H}, ccptn_t const * @var{P})
Like @cfunc{ccptn_init_dirname}, but register the resulting instance of @objtype{ccptn_t} to be
released by the clean handler referenced by @var{H}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Generic preprocessor macros


@deftypefn {Preprocessor Macro} {ccptn_t *} ccptn_new_dirname_guarded (cce_destination_t @var{L}, @var{H}, ccptn_t const * @var{P})
This macro uses @code{_Generic} to dispatch its expansion according to the type of @var{H}; if the
type is a pointer to:

@table @code
@item cce_clean_handler_t
The macro expands into a call to @cfunc{ccptn_new_dirname_guarded_clean}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccptn_new_dirname_guarded_error}.
@end table
@end deftypefn


@deftypefn {Preprocessor Macro} {ccptn_t *} ccptn_init_dirname_guarded (cce_destination_t @var{L}, ccptn_t * @var{R}, @var{H}, ccptn_t const * @var{P})
This macro uses @code{_Generic} to dispatch its expansion according to the type of @var{H}; if the
type is a pointer to:

@table @code
@item cce_clean_handler_t
The macro expands into a call to @cfunc{ccptn_init_dirname_guarded_clean}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccptn_init_dirname_guarded_error}.
@end table
@end deftypefn

@c page
@node components tailnames
@section Extracting pathname tailnames


The @dfn{tailname} is the relative pathname representing the last segment of an input pathname.
Examples:

@example
"/path/to/file.ext"     @result{} "file.ext"
"/path/to/dir/"         @result{} "dir/"
"file.ext"              @result{} "file.ext"
"."                     @result{} "."
".."                    @result{} ".."
"/"                     @error{} no tailname
@end example

Every pathname has a tailname with the exception of @file{/}.

It is an error to attempt tailname extraction from an input pathname that has no tailname; in this
case the functions below will raise an exception of type @objtype{ccptn_condition_no_tailname_t}.

Tailname extraction is possible only for an input pathname that has been previously normalised; if
the input is not normalised: the functions below will raise an exception of type
@objtype{ccptn_condition_normalised_pathname_t}.


@deftypefun {ccptn_t *} ccptn_new_tailname (cce_destination_t @var{L}, ccptn_t const * @var{P})
Build and return a new instance of @objtype{ccptn_t} representing the tailname of the input pathname
referenced by @var{P}.  If an error occurs: raise an exception by performing a non--local exit to
@var{L}.
@end deftypefun


@deftypefun {ccptn_t *} ccptn_init_tailname (cce_destination_t @var{L}, ccptn_t * @var{R}, ccptn_t const * @var{P})
Initialise an already allocated instance of @objtype{ccptn_t}, referenced by @var{R}, representing
the tailname of the input pathname referenced by @var{P}.  If an error occurs: raise an exception by
performing a non--local exit to @var{L}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Guarded functions for error handlers


@deftypefun {ccptn_t *} ccptn_new_tailname_guarded_error (cce_destination_t @var{L}, cce_error_handler_t * @var{H}, ccptn_t const * @var{P})
Like @cfunc{ccptn_new_tailname}, but register the resulting instance of @objtype{ccptn_t} to be
released by the error handler referenced by @var{H}.
@end deftypefun


@deftypefun {ccptn_t *} ccptn_init_tailname_guarded_error (cce_destination_t @var{L}, ccptn_t * @var{R}, cce_error_handler_t * @var{H}, ccptn_t const * @var{P})
Like @cfunc{ccptn_init_tailname}, but register the resulting instance of @objtype{ccptn_t} to be
released by the error handler referenced by @var{H}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Guarded functions for clean handlers


@deftypefun {ccptn_t *} ccptn_new_tailname_guarded_clean (cce_destination_t @var{L}, cce_clean_handler_t * @var{H}, ccptn_t const * @var{P})
Like @cfunc{ccptn_new_tailname}, but register the resulting instance of @objtype{ccptn_t} to be
released by the clean handler referenced by @var{H}.
@end deftypefun


@deftypefun {ccptn_t *} ccptn_init_tailname_guarded_clean (cce_destination_t @var{L}, ccptn_t * @var{R}, cce_clean_handler_t * @var{H}, ccptn_t const * @var{P})
Like @cfunc{ccptn_init_tailname}, but register the resulting instance of @objtype{ccptn_t} to be
released by the clean handler referenced by @var{H}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Generic preprocessor macros


@deftypefn {Preprocessor Macro} {ccptn_t *} ccptn_new_tailname_guarded (cce_destination_t @var{L}, @var{H}, ccptn_t const * @var{P})
This macro uses @code{_Generic} to dispatch its expansion according to the type of @var{H}; if the
type is a pointer to:

@table @code
@item cce_clean_handler_t
The macro expands into a call to @cfunc{ccptn_new_tailname_guarded_clean}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccptn_new_tailname_guarded_error}.
@end table
@end deftypefn


@deftypefn {Preprocessor Macro} {ccptn_t *} ccptn_init_tailname_guarded (cce_destination_t @var{L}, ccptn_t * @var{R}, @var{H}, ccptn_t const * @var{P})
This macro uses @code{_Generic} to dispatch its expansion according to the type of @var{H}; if the
type is a pointer to:

@table @code
@item cce_clean_handler_t
The macro expands into a call to @cfunc{ccptn_init_tailname_guarded_clean}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccptn_init_tailname_guarded_error}.
@end table
@end deftypefn

@c page
@node components filenames
@section Extracting pathname filenames


The @dfn{filename} is the relative pathname representing the last segment of an input pathname, if
it does not represent a directory.  Examples:

@example
"/path/to/file.ext"     @result{} "file.ext"
"/path/to/dir/"         @error{} no filename
"file.ext"              @result{} "file.ext"
"."                     @error{} no filename
".."                    @error{} no filename
"/"                     @error{} no filename
@end example

It is an error to attempt filename extraction from an input pathname that has no filename; in this
case the functions below will raise an exception of type @objtype{ccptn_condition_no_filename_t}.

Filename extraction is possible only for an input pathname that has been previously normalised; if
the input is not normalised: the functions below will raise an exception of type
@objtype{ccptn_condition_normalised_pathname_t}.


@deftypefun {ccptn_t *} ccptn_new_filename (cce_destination_t @var{L}, ccptn_t const * @var{P})
Build and return a new instance of @objtype{ccptn_t} representing the filename of the input pathname
referenced by @var{P}.  If an error occurs: raise an exception by performing a non--local exit to
@var{L}.
@end deftypefun


@deftypefun {ccptn_t *} ccptn_init_filename (cce_destination_t @var{L}, ccptn_t * @var{R}, ccptn_t const * @var{P})
Initialise an already allocated instance of @objtype{ccptn_t}, referenced by @var{R}, representing
the filename of the input pathname referenced by @var{P}.  If an error occurs: raise an exception by
performing a non--local exit to @var{L}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Guarded functions for error handlers


@deftypefun {ccptn_t *} ccptn_new_filename_guarded_error (cce_destination_t @var{L}, cce_error_handler_t * @var{H}, ccptn_t const * @var{P})
Like @cfunc{ccptn_new_filename}, but register the resulting instance of @objtype{ccptn_t} to be
released by the error handler referenced by @var{H}.
@end deftypefun


@deftypefun {ccptn_t *} ccptn_init_filename_guarded_error (cce_destination_t @var{L}, ccptn_t * @var{R}, cce_error_handler_t * @var{H}, ccptn_t const * @var{P})
Like @cfunc{ccptn_init_filename}, but register the resulting instance of @objtype{ccptn_t} to be
released by the error handler referenced by @var{H}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Guarded functions for clean handlers


@deftypefun {ccptn_t *} ccptn_new_filename_guarded_clean (cce_destination_t @var{L}, cce_clean_handler_t * @var{H}, ccptn_t const * @var{P})
Like @cfunc{ccptn_new_filename}, but register the resulting instance of @objtype{ccptn_t} to be
released by the clean handler referenced by @var{H}.
@end deftypefun


@deftypefun {ccptn_t *} ccptn_init_filename_guarded_clean (cce_destination_t @var{L}, ccptn_t * @var{R}, cce_clean_handler_t * @var{H}, ccptn_t const * @var{P})
Like @cfunc{ccptn_init_filename}, but register the resulting instance of @objtype{ccptn_t} to be
released by the clean handler referenced by @var{H}.
@end deftypefun

@c ------------------------------------------------------------------------

@subsubheading Generic preprocessor macros


@deftypefn {Preprocessor Macro} {ccptn_t *} ccptn_new_filename_guarded (cce_destination_t @var{L}, @var{H}, ccptn_t const * @var{P})
This macro uses @code{_Generic} to dispatch its expansion according to the type of @var{H}; if the
type is a pointer to:

@table @code
@item cce_clean_handler_t
The macro expands into a call to @cfunc{ccptn_new_filename_guarded_clean}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccptn_new_filename_guarded_error}.
@end table
@end deftypefn


@deftypefn {Preprocessor Macro} {ccptn_t *} ccptn_init_filename_guarded (cce_destination_t @var{L}, ccptn_t * @var{R}, @var{H}, ccptn_t const * @var{P})
This macro uses @code{_Generic} to dispatch its expansion according to the type of @var{H}; if the
type is a pointer to:

@table @code
@item cce_clean_handler_t
The macro expands into a call to @cfunc{ccptn_init_filename_guarded_clean}.

@item cce_error_handler_t
The macro expands into a call to @cfunc{ccptn_init_filename_guarded_error}.
@end table
@end deftypefn

@c page
@node io
@chapter Pathname input/output


@deftypefun void ccptn_print (cce_destination_t @var{L}, FILE * @var{stream}, ccptn_t const * @var{P})
Print the pathname to @var{stream}; do not flush the stream.  If an error occurs: raise an exception
by performing a non--local exit to @var{L}.
@end deftypefun

@c page
@node segments
@chapter Manipulating segments


@deftp {Struct Typedef} ccptn_segment_t
This @code{struct} represents a segment in a pathname; this struct does not own the referenced
memory.  Given the pathname:

@example
/path/to/file.ext
@end example

@noindent
the segments are the strings:

@example
path
to
file.ext
@end example

@noindent
notice that the slash separators are @strong{excluded}.  This type has the following fields:

@table @code
@item size_t len
The number of octets in the @code{ptr} array representing a segment of pathname.

@item char const * ptr
Pointer to the first octet in an @ascii{} string representing a pathname's segment.  In general, it
is @strong{not} an @asciiz{} string: it is not zero terminated.
@end table
@end deftp


@deftypefun bool ccptn_segment_is_empty (ccptn_segment_t @var{S})
Return @ctrue{} if @var{S} is empty; otherwise return @cfalse{}.
@end deftypefun


@deftypefun bool ccptn_segment_is_dot (ccptn_segment_t @var{S})
Return @ctrue{} if @var{S} represents a single dot: @samp{.}; otherwise return @cfalse{}.
@end deftypefun


@deftypefun bool ccptn_segment_is_double_dot (ccptn_segment_t @var{S})
Return @ctrue{} if @var{S} represents a double dot: @samp{..}; otherwise return @cfalse{}.
@end deftypefun


@deftypefun ccptn_segment_t ccptn_segment_next (char const * @var{ptr}, size_t @var{len})
Given a pointer @var{ptr} to an @ascii{} string of at least @var{len} octets: return a segment
@code{struct} referencing the octects up to, but not including, the first slash character or the end
of the string.  The returned segment does @strong{not} include a terminating zero octet.
@end deftypefun


@deftypefun size_t ccptn_segment_size_of_next (char const * @var{in}, size_t @var{len})
Given a pointer @var{in} to an @ascii{} string of at least @var{len} octets: return the number of
octets between the one referenced by @var{in} (included) and the first slash octet (excluded);
return @var{len} itself if no slash is found.
@end deftypefun


@deftypefun void ccptn_segment_print (cce_destination_t @var{L}, FILE * @var{stream}, ccptn_segment_t @var{S})
Print the segment to @var{stream}; do not flush the stream.  If an error occurs: raise an exception
by performing a non--local exit to @var{L}.
@end deftypefun

@c page
@node extensions
@chapter Manipulating extensions


@deftp {Struct Typedef} ccptn_extension_t
This @code{struct} represents the extension of a segment in a pathname; this struct does not own the
referenced memory.  Given the pathname:

@example
/path/to/file.ext
@end example

@noindent
the last segment is the string @samp{file.ext} and its extension is the string @samp{.ext},
@strong{including} the leading dot.

This type has the following fields:

@table @code
@item size_t len
The number of octets in the @code{ptr} array representing the extension in a pathname's segment.

@item char const * ptr
Pointer to the first octet in an @ascii{} string representing a pathname's segment's extension.  In
general this string is @strong{not} zero terminated.
@end table
@end deftp


@deftypefun bool ccptn_extension_is_empty (ccptn_extension_t @var{E})
Return @ctrue{} if @var{E} is empty; otherwise return @cfalse{}.
@end deftypefun


@deftypefun bool ccptn_extension_equal (ccptn_extension_t @vari{E}, ccptn_extension_t @varii{E})
Return @ctrue{} if the extensions are equal octet by octet; otherwise return @cfalse{}.
@end deftypefun


@deftypefun void ccptn_extension_print (cce_destination_t @var{L}, FILE * @var{stream}, ccptn_extension_t @var{E})
Print the extension to @var{stream}; do not flush the stream.  If an error occurs: raise an
exception by performing a non--local exit to @var{L}.
@end deftypefun

@c page
@node utils
@chapter Utility definitions


@defmac CCPTN_PC (@var{POINTER_TYPE}, @var{POINTER_NAME}, @var{EXPRESSION})
Preprocessor macro used to define pointer variables initialised with a cast expression.  It expands
to:

@example
POINTER_TYPE * POINTER_NAME = (POINTER_TYPE *) (EXPRESSION)
@end example

For example, the macro use:

@example
CCPTN_PC(ccpathnames_descriptor_test_failure_t, C, _C);
@end example

@noindent
expands into:

@example
ccpathnames_descriptor_test_failure_t * C = \
   (ccpathnames_descriptor_test_failure_t *) (_C);
@end example
@end defmac


@defmac CCPTN_UNUSED
Preprocessor macro that is meant to expand into an attribute declaration.  If the symbol
@code{__GNUC__} is defined, the expansion is:

@example
__attribute__((__unused__))
@end example

@noindent
otherwise the expansion is the empty string.
@end defmac

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include lgpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DOCUMENTATION_URL}

@noindent
the latest release of this package can be downloaded from:

@center @value{DOWNLOAD_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@noindent
the package CCExceptions is available at:

@center @url{https://github.com/marcomaggi/ccexceptions/}

@noindent
the package CCMemory is available at:

@center @url{https://github.com/marcomaggi/ccmemory/}

@noindent
the package CCTests is available at:

@center @url{https://github.com/marcomaggi/cctests/}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

